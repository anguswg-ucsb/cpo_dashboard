---
title: "CPO"
runtime: shiny
output: 
  flexdashboard::flex_dashboard:
    css: www/custom.css
    navbar:
      - { icon: "fa-question-circle", href: "https://github.com/anguswg-ucsb/drought_data_processing", align: right }
    theme: cerulean
    orientation: columns
    source_code: embed
    vertical_layout: fill
---

```{r setup, include = FALSE}
# Shiny & Flexdashboard libraries
library(shiny)
library(flexdashboard)

# Data libraries
library(tidyr)
library(dplyr)
library(purrr)
library(leaflet)
library(sf)
library(tools)
library(highcharter)
library(viridis)
library(shinyalert)
library(shinyhelper)
library(rintrojs)
library(htmltools)
library(shinyLP)
library(shinyBS)
source('data_utils.R')
```


```{r context="server"}
useShinyalert(rmd = TRUE)
# districts for analysis
distr_num <- c(1,  2,  4,  5,  6,  7,  8,  9,  23, 64, 80,
               36, 37, # 38, 
               39, 45, 50, 51, 52, 53, 70, 72)

# district shapefile path
shp_path = "water_districts_simple.geojson"

 # load shapefiles as spatial polygon object
shp <- sf::read_sf(paste0(shp_path), quiet = TRUE) %>%
  filter(DISTRICT %in% distr_num) %>%
  st_transform(4326) %>% 
  st_cast("MULTIPOLYGON")

# Tidied MLR results by district
tidy_mlr <- readRDS("tidy_mlr.rds")

shp <- left_join(shp, tidy_mlr, by = c("DISTRICT" = "district"))


maca <- readRDS("maca_data.rds")
# loca <- readRDS("loca_data.rds")
# bcca <- readRDS("bcca_data.rds")


# node_pts <- readRDS("node_pts.rds")
node_pts <- readRDS("node_pts2.rds")

# ditch_data <- readRDS("ditch_data.rds")
ditch_data <- readRDS("ditch_data2.rds")

impacts_lst <- list(
  "Total shortage"              = "short",
  "Normalized total shortage"   = "short_norm",
  "Direct shortage"             = "short_dir",
  "Normalized direct shortage"  = "short_dir_norm",
  "Natural flows"               = "af_total"
)

# basins <- readRDS("basin_outline.rds")
# 
# rivers <- readRDS("basin_rivers.rds")


#Initialize Maps 
output$districtMap     <- renderLeaflet({ basemap(shp = shp) })
output$nodeMap         <- renderLeaflet({ basemap(shp = shp) })
```

Home
=====================================
```{r}
 tags$body(
    tags$h1(tags$strong('Drought conditions and water shortages')),
    tags$p('Drought conditions produce large economic impacts in water-limited communities, and are becoming more frequent and severe. When productivity of agricultural, municipal, and industrial operations are limited by available water, drought is a significant risk. One way to understand drought’s impacts on these communities is quantifying administrative water shortage – or the difference between water allocated supply and desired demand – and its sensitivity to climatic variables that are used to describe drought. '),
    tags$p('Lynker scientists evaluated water districts in the South Platte and Colorado River Basins in the State of Colorado to explore the sensitivity of water shortages to drought conditions. We created this interactive dashboard for you to explore yourself.'),
    tags$hr(),
    tags$h2(tags$strong('How it works:')),
    tags$p('1. This dashboard uses supply and demand data from water rights using Statemod, a water allocation model developed by the State of Colorado to represent water rights operations within the state’s unique and carefully managed administrative regime. Statemod has more than 500 model nodes in both the Colorado and South Platte river basins.'),
    tags$p('2. Climate data is from the gridMET climate dataset which contains daily gridded climate data at a ~4km spatial resolution  for the period 1980 – 2012. These data are used in various ways to measure or understand drought and drought severity.  Types of data include hydroclimate data and drought indexes.'),
    tags$ul(
    tags$li("Temperature (C)"),
    tags$li("Precipitation (mm)"),
    tags$li("Snow water equivalent (SWE) (mm)"),
    tags$li("Potential Evapotranspiration (mm)"),
    tags$li("Soil Moisture (mm)"),
    tags$li("Palmer Drought Severity Index"),
    tags$li("Evaporative Demand Drought Index (1, 3, 6, 9, and 12 month)"),
    tags$li("Standard Precipitation Index  (1, 3, 6, 9, and 12 month)")
),
    tags$p('3. Data is aggregated by water districts in the South Platte and Colorado River Basins.'),
  tags$br(),
  tags$hr(),
  tags$br(),
    tags$h1(tags$strong('Dashboards')),
 tags$h2(tags$strong('Multiple Linear regression')),
 tags$p(tags$i(tags$strong("How sensitive are districts to climate? What combination of drought predictors best predict water shortages?"))),
 tags$p('Using a multiple linear regression (MLR) approach, we found the climate indicators that best predict water shortages (demand – supply) for each district. District by district, you can see the climate predictors that have been included in the model'),
 tags$img(src = "mlr_map_v3.png", width = "400px", height = "300px"),
  tags$br(),
  tags$hr(),
  tags$br(),
 tags$h2(tags$strong('Univariate Linear regression')),
 tags$p(tags$i(tags$strong("How do climate variables relate to shortages?"))),
 tags$p("We can quantify the strength of the relationship between a single climate predictor and water shortages (the explanatory variable) by performing a linear regression analysis.
For example, it is intuitive that if precipitation in a district decreases, then the water available for use drops, creating a mismatch between supply and demand. The slope of this line (the strength of the relationship) varies by district. Explore all the other relationships between climate predictors and water shortages here."),
  tags$br(),
  tags$hr(),
  tags$br(),
 tags$h2(tags$strong('Water Rights')),
 tags$p(tags$i(tags$strong("How are individual diversion structures (water rights) water shortages change over time?"))),
 tags$p("Water districts have a unique portfolio of water rights, consisting of irrigators, municipalities, and other users. This tab explores the diversion locations, demands, and direct flow shortages (demand – direct flow supply) at each headgate.
Water rights with later more recent appropriation dates are more likely to experience water shortages than senior water rights with early appropriation dates."),
 tags$img(src = "water_rights_pic.png", width = "400px", height = "300px"),
  tags$br(),
  tags$hr(),
  tags$br(),
 tags$h2(tags$strong('Climate Change Impacts')),
 tags$p(tags$i(tags$strong("How will climate change affect water shortages in the future?"))),
 tags$p("Using climate models centered around the year 2050, we can create new climate data inputs. Then, using our multiple linear regression models (see first tab), we can see how shortages can be impacted by a shift in climate data.​"),
 tags$img(src = "density_plot_img.png", width = "400px", height = "300px"),
  tags$br(),
  tags$hr(),
  tags$br(),
 tags$div(class = "header", checked = NA,
 tags$p("Ready to take the Shiny tutorial? If so"),
 tags$a(href = "shiny.rstudio.com/tutorial", "Click Here!")
)
 )

```


Water ditches
=======================================
Inputs {.sidebar}
----------------------------------------------------
### **Linear Regression model:**

*** 

<br>
<!-- ### HTML and JavaScript -->

<!-- <button id="btn">Click me</button> -->

<!-- ```{js, echo=FALSE} -->
<!-- $("#btn").on("click", function() { -->
<!--   alert("You clicked the button!") -->
<!-- }) -->
<!-- ``` -->

<!-- ### HTML using 'htmltools' -->

<!-- ```{r, echo=FALSE} -->
<!-- tags$button("Another button") -->
<!-- ``` -->

### Alerts
```{r}
library(shinyalert)
# useShinyalert(rmd = TRUE)
# introjsUI()
# textInput("name", "Name")
 
# introBox(
#   actionButton("button", "Click me"),
#   data.step = 1,
#   data.intro = "This is a button",
#   data.hint = "You can press me"
#       )
# observeEvent(input$button,
#                introjs(session, options = list("nextLabel"="Onwards and Upwards",
#                                                "prevLabel"="Did you forget something?",
#                                                "skipLabel"="Don't be a quitter"),
#                                 events = list("oncomplete"=I('alert("Glad that is over")')))
#   )
#   
# introBox(
#         textInput("name", "Name"),
#         data.step = 2,
#         data.intro = "This is a button",
#         data.hint = "You can press me"
#       )
# textInput("intro","Enter an introduction")
# 
# actionButton("btn","Press me")
 
# observeEvent(input$button, {
#   shinyalert(title = "Hey", text = input$name)
# })
```


### Select 1
```{r, context = "server"}
 #  steps <- reactive(data.frame(element = c(NA,"#btn"),
 #                               intro = c(input$intro,"This is a button")))
 #  
 # observeEvent(input$btn,{
 #    introjs(options = list(steps=steps()))
 # })
# start introjs when button is pressed with custom options and events

# observeEvent(input$helpButton, {
#       shinyalert(html = TRUE, text = tagList(
#           selectInput(
#               "depVarInput",
#               label = NULL,
#               selected = "Total shortage",
#               choices = impacts_lst),
#           selectInput(
#               "climVarInput",
#               label = NULL,
#               selected = "Total shortage",
#               choices = impacts_lst)
#           ),
#            callbackR = function(x) { paste0(input$climVarInput) })
#   })

# modelInputs <- eventReactive()
```

<!-- ### Select 2 -->
<!-- ```{r} -->

<!-- selectInput( -->
<!--   "climVarInput", -->
<!--   label = NULL, -->
<!--   # selected = "short_norm", -->
<!--     # choices = as.list(outcome_lst$outcome_variable) -->
<!--   selected = "Total shortage", -->
<!--   choices = impacts_lst) -->
<!-- ``` -->

<br>

#### **Submit**
```{r}
#
# actionButton(
#   "helpButton",
#   label = "Info",
#   class = "btn-primary btn-lg",
#   icon("search")
#   )

# observeEvent(input$helpButton, {
#   shinyalert(title = "Hey",showCancelButton = TRUE, text = "Press this button to run the model")
# })
# actionButton(
#   "helpButton",
#   # label = "Help",
#   # class = "btn-primary btn-lg",
#   icon("question")
#   )
# observeEvent(input$helpButton, {
#   shinyalert(title = "Hey",showCancelButton = TRUE, text = "Press this button to run the model")
# })
```


```{r}
verbatimTextOutput("inputText")
```

```{r context = "server"}
output$inputText <- renderPrint({
  input$climVarInput
})
```


<!-- ### UI -->
<!-- ```{r} -->
<!-- actionLink( -->
<!--   "helpButton", -->
<!--   label = "Help" -->
<!--   # class = "btn-primary btn-lg", -->
<!--   # icon("search") -->
<!--   ) -->
<!-- # uiOutput("dynamicUI") -->
<!-- ``` -->

```{r context="server"}
# 
# observeEvent(input$helpButton, {
#       showModal(modalDialog(
#         title = "Important message",
#         "This is an important message!",
#         easyClose = TRUE
#       ))
# })
 # observeEvent(input$submitButton,
 #              introjs(session,
 #                      options = list(
 #                         "showBullets"="false", "showProgress"="true", 
 #                         "showStepNumbers"="false","nextLabel"="Next",
 #                         "prevLabel"="Prev","skipLabel"="Skip"))
 #    )
# observe_helpers()
# 
# output$dynamicUI <- renderUI({
#   actionButton(
#     "submitButton",
#     label = "Enter",
#     class = "btn-primary btn-lg",
#     icon("search")
#   ) %>%
#     helper(icon = "question",
#              colour = "orange",
#              size = "s",
#              type = "inline",
#              title = "Current Details")
#   })

```

***

Column {data-width=450}
-----------------------------------------------------------------------
### Water districts
```{r}
leafletOutput("districtMap")
```

### District
```{r}
valueBoxOutput("districtBoxNode")
```

### Nodes
```{r}
leafletOutput("nodeMap")
# uiOutput("nodeMapUI") 
# actionButton(
#   "helpButton",
#   label = "",
#   class = "btn-secondary", 
#   # class = "btn-primary btn-lg",
#   icon = icon("question-circle")
#   )
```

```{r context="server"}


# output$nodeMapUI <- renderUI({
# leafletOutput("nodeMap") %>% 
#     helper(icon = "question",
#              colour = "orange",
#              size = "s",
#              type = "inline",
#              title = "Current Details")
#   })
# render district value box at start
output$districtBoxNode <- renderValueBox(
                    valueBox(
                      value = "District",
                      color = "success"
                  )
                )

# Clicking on map 1 outputs Value boxes on both pages + catchment polygons + Dat table + success panel
observeEvent(input$districtMap_click, {
       if(!is.null(input$districtMap_click)) {
          click <- input$districtMap_click %>%
            data.frame() %>%
            dplyr::select(lat,lng)
          print(click)
    
          pt <- sf::st_as_sf(
            click,
            coords = c("lng", "lat"),
            crs = 4326
            )
    
          # point intersection w/ polygons
          pt_intersect <-  st_filter(shp, pt)
    
          # ensure  app will not crash if a somewhere other than a shape is clicked and returns no results from point-shape intersection
           if(nrow(pt_intersect) == 0) {
              NULL
           } else {
              district_id <- pt_intersect %>%
                  rename(district = DISTRICT) %>%
                  mutate(district = as.numeric(district))
    
              # District number value box
              output$districtBoxNode <- renderValueBox(
                valueBox(
                  value = paste0("District ", district_id$district),
                  color = "success"
                  )
                )
              pal <- colorNumeric("YlOrRd", domain = shp$variance_rsq, n = 21)
              # bb = shp %>%
              #     st_bbox() %>%
              #     st_as_sfc() %>%
              #     st_transform(4326) %>%
              #     st_as_sf()
              # # Map 2 fly to bounds
              # bounds <- st_bbox(bb) %>%
              #     st_as_sfc() %>%
              #     st_buffer(0.009) %>%
              #     st_bbox() %>%
              #     as.vector()
            pal <- colorFactor(c("darkorange", "pink"), domain = shp$BASIN)
            
              leafletProxy("districtMap") %>%
                  clearMarkers() %>%
                  clearShapes() %>%
                  addMarkers(data = pt) %>%
                  addPolygons(
                        data = shp,
                        color = "black",
                        fillOpacity = 0.8,
                        fillColor = ~pal(BASIN),
                        # fillColor = ~pal(variance_rsq),
                        weight = 2,
                        label = ~DISTRICT,
                        labelOptions = labelOptions(
                          noHide = F,
                          # direction = 'center',
                          # textOnly = F)
                          style = list(
                            "color" = "black",
                            "font-weight" = "1000")
                          )
                      )
                  # addPolylines(
                  #       data = basins[1,],
                  #       # col = "red",
                  #       col = "black",
                  #       weight = 5,
                  #       opacity = 1,
                  #       label = ~basin_clean,
                  # ) %>%
                  # addPolylines(
                  #       data = basins[2,],
                  #       # col = "green",
                  #       col = "black",
                  #       weight = 5,
                  #       opacity = 1,
                  #       label = ~basin_clean,
                  #   ) %>%
                  # addPolylines(
                  #       data = rivers,
                  #       col = "blue",
                  #       # col = "dodgerblue",
                  #       weight = 3.5,
                  #       opacity = 1
                  #     )
              bb = shp %>%
                  # filter(DISTRICT == 6) %>% 
                  filter(DISTRICT == district_id$district) %>% 
                  st_bbox() %>%
                  st_as_sfc() %>%
                  st_transform(4326) %>%
                  st_as_sf()
              
              # Fly to bounds on Node map
              bounds <- st_bbox(bb) %>%
                  st_as_sfc() %>%
                  # st_buffer(0.009) %>%
                  st_bbox() %>%
                  as.vector()
              
              node_marker <- node_pts %>%
                # filter(district == 6) %>% 
                filter(district == district_id$district) %>%
                mutate(size = abs(avg_dem - mean(avg_dem))/ sd(avg_dem))
              
              leafletProxy("nodeMap") %>%
                    clearMarkers() %>%
                    clearShapes() %>%
                leaflet() %>% 
                    addPolygons(
                          data = filter(shp, 
                                        DISTRICT == district_id$district
                                        # DISTRICT == 6
                                        ),
                          fillColor = 'white',
                          fillOpacity = 0.4,
                          col = "black",
                          weight = 2,
                          label = ~DISTRICT,
                          labelOptions = labelOptions(
                              noHide = F,
                              # direction = 'center',
                              # textOnly = F)
                              style = list(
                                "color" = "black",
                                "font-weight" = "1000")
                        )
                      ) %>% 
                     addCircleMarkers(
                          data = node_marker,
                          radius = ~(3.5 + size*5),
                          # radius = 7,
                          color = "black",
                          fillColor ="red",
                          fillOpacity = 0.7,
                          weight = 3,
                          layerId = ~node_id,
                          label = ~admin,
                          stroke = TRUE
                          ) %>% 
                    # addPolylines(
                    #       data = basins[1,],
                    #       # col = "red",
                    #       col = "black",
                    #       weight = 5,
                    #       opacity = 1,
                    #       label = ~basin_clean
                    #       ) %>%
                    # addPolylines(
                    #       data = basins[2,],
                    #       # col = "green",
                    #       col = "black",
                    #       weight = 5,
                    #       opacity = 1,
                    #       label = ~basin_clean
                    #       ) %>%
                    # addPolylines(
                    #       data = rivers,
                    #       col = "blue",
                    #       # col = "dodgerblue",
                    #       weight = 3.5,
                    #       opacity = 1 
                    #       ) %>% 
                flyToBounds(bounds[1], bounds[2], bounds[3], bounds[4])
          
              # output$nodeText <- renderText({
              #   paste0(node_marker)
              # })
             # trans_log <- by_district %>%
             #      mutate(
             #        short               = log10(short),
             #        short_dir           = log10(short_dir),
             #        short_norm          = log10(short_norm),
             #        short_dir_norm      = log10(short_dir_norm),
             #        aug_supply          = log10(aug_supply),
             #        aug_supply_norm     = log10(aug_supply_norm),
             #        supply              = log10(supply),
             #        supply_dir          = log10(supply_dir),
             #        demand              = log10(demand)
             #      )
             #    
             #    # replace Infinite w/ 0
             #    is.na(trans_log) <- sapply(trans_log, is.infinite)
             #    trans_log[is.na(trans_log)] <- 0
             #    
             #    # by_right_scale <- group_by(by_right_scale, district, water_right)
             #    data_new <- group_by(trans_log, district)
           }}
      })
```

<!-- Column {data-width=450} -->
<!-- ----------------------------------------------------------------------- -->
<!-- ### Admin shortages -->
<!-- ```{r} -->
<!-- highcharter::highchartOutput("adminShortagePlot") -->
<!-- ``` -->

<!-- ```{r context="server"} -->
<!-- observeEvent(input$nodeMap_marker_click, { -->
<!--     node <<- input$nodeMap_marker_click$id -->
<!--     # ---- Node timeseries ---- -->
<!--     # filter data to node -->
<!--     # ditch <- ditch_data %>% -->
<!--     #   filter(node_id == node) %>% -->
<!--     #   group_by(year, admin) %>% -->
<!--     #   summarize(across(c(19:24), sum)) %>%  -->
<!--     #   ungroup() -->

<!--     # split node by admin -->
<!--     node_split_short <- ditch_data %>%  -->
<!--       filter(node_id == node) %>% -->
<!--       # filter(node_id == "0700699") %>% -->
<!--       mutate(admin = round(as.numeric(admin), 0)) %>%  -->
<!--       group_by(admin) %>%  -->
<!--       mutate(x = year, y = round(short_dir, 1)) %>%  -->
<!--       dplyr::select(x, y, admin) %>%  -->
<!--       group_split() %>%  -->
<!--       as.list() -->

<!--     # initialize highchart -->
<!--     admin_short_hc <- highchart() %>%  -->
<!--        hc_plotOptions( -->
<!--                 # series = list(label = list(enabled = FALSE)), -->
<!--                 line = list(marker = list(enabled = FALSE, symbol = "circle"), label = list(enabled = FALSE), lineWidth = 4), -->
<!--                 area = list(stacking = 'normal', label = list(enabled = FALSE)), -->
<!--                 column = list(stacking = 'normal', label = list(enabled = FALSE)), -->
<!--                 bar = list(stacking = 'normal', label = list(enabled = FALSE)) -->
<!--             ) %>% -->
<!--         hc_title(text = "Shortages") %>%  -->
<!--         hc_colors(viridis::cividis(n = length(node_split_short))) %>% -->
<!--         hc_xAxis(categories = node_split_short[[1]][1], -->
<!--                  labels = list(style = list(fontSize =  '1.1em'))) %>%  -->
<!--         hc_yAxis(title = list( -->
<!--                             text =  "Direct flow shortage (acre feet)", -->
<!--                             style = list(fontWeight = "bold",  fontSize = '1.2em')), -->
<!--                  labels = list(style = list(fontSize =  '1.1em'))) %>%   -->
<!--         hc_chart(plotBorderWidth = 0.5, plotBorderColor = '#b4b4b4', height = NULL) -->

<!--     # for loop to generate highcharter series for each admin number -->
<!--     for (i in 1:length(node_split_short)) { -->
<!--       admin_short_hc <- admin_short_hc %>% -->
<!--           hc_add_series(node_split_short[[i]], name = paste0(node_split_short[[i]][1,3]), type = "area", fillOpacity = 1) -->
<!--       } -->

<!--     output$adminShortagePlot <- renderHighchart({ -->
<!--        admin_short_hc -->
<!--       }) -->
<!-- }) -->
<!-- ``` -->

<!-- ### Admin demand -->
<!-- ```{r} -->
<!-- highcharter::highchartOutput("adminDemandPlot") -->
<!-- ``` -->

<!-- ```{r context="server"} -->
<!-- observeEvent(input$nodeMap_marker_click, { -->
<!--     node <<- input$nodeMap_marker_click$id -->

<!--     node_split_demand <- ditch_data %>%  -->
<!--       filter(node_id == node) %>% -->
<!--       # filter(node_id == "0700699") %>% -->
<!--       mutate(admin = round(as.numeric(admin), 0)) %>%  -->
<!--       group_by(admin) %>%  -->
<!--       mutate(x = year, y = round(demand_dir, 1)) %>%  -->
<!--       dplyr::select(x, y, admin) %>%  -->
<!--       group_split() %>%  -->
<!--       as.list() -->

<!--     # initialize highchart -->
<!--     admin_dem_hc <- highchart() %>% -->
<!--       highchart() %>%  -->
<!--           hc_plotOptions( -->
<!--               # series = list(label = list(enabled = FALSE)), -->
<!--               line = list(marker = list(enabled = FALSE, symbol = "circle"), label = list(enabled = FALSE), lineWidth = 4), -->
<!--               area = list(stacking = 'normal', label = list(enabled = FALSE)), -->
<!--               column = list(stacking = 'normal', label = list(enabled = FALSE)), -->
<!--               bar = list(stacking = 'normal', label = list(enabled = FALSE)) -->
<!--           ) %>% -->
<!--           hc_title(text = "Demand") %>%  -->
<!--           hc_colors(viridis::cividis(n = length(node_split_demand))) %>% -->
<!--           hc_xAxis(categories = node_split_demand[[1]][1], -->
<!--                    labels = list(style = list(fontSize =  '1.1em'))) %>%  -->
<!--           hc_yAxis(title = list( -->
<!--                               text =  "Demand (acre feet)", -->
<!--                               style = list(fontWeight = "bold",  fontSize = '1.2em')), -->
<!--                    labels = list(style = list(fontSize =  '1.1em'))) %>%   -->
<!--           hc_chart(plotBorderWidth = 0.5, plotBorderColor = '#b4b4b4', height = NULL) -->


<!--     # for loop to generate highcharter series for each admin number -->
<!--     for (i in 1:length(node_split_demand)) { -->
<!--       admin_dem_hc <- admin_dem_hc %>% -->
<!--         hc_add_series(node_split_demand[[i]], name = paste0(node_split_demand[[i]][1,3]), type = "area", fillOpacity = 0.7) -->
<!--       } -->


<!--     output$adminDemandPlot <- renderHighchart({ -->
<!--        admin_dem_hc -->
<!--       }) -->
<!-- }) -->
<!-- ``` -->



<!-- Column {data-width=550} -->
<!-- ------------------------------------- -->
<!-- ### Predicted Water Shortages -->
<!-- ```{r} -->
<!-- highcharter::highchartOutput("MLRpredictionPlot") -->
<!-- ``` -->

<!-- ```{r context = "server"} -->
<!-- MLRpredictionData <- eventReactive(input$submitButton2, { -->
<!--    # if(!is.null(input$districtMapFuture_click)) { -->
<!--       click <- input$districtMapFuture_click %>% -->
<!--             data.frame() %>% -->
<!--             dplyr::select(lat,lng) -->

<!--           pt <- sf::st_as_sf( -->
<!--             click, -->
<!--             coords = c("lng", "lat"), -->
<!--             crs = 4326 -->
<!--             ) -->
<!--           # point intersection w/ polygons -->
<!--           pt_intersect <-  st_filter(shp, pt) -->

<!--           # ensure  app will not crash if a somewhere other than a shape is clicked and returns no results from point-shape intersection -->
<!--           if(nrow(pt_intersect) == 0) { -->
<!--               NULL -->
<!--              } else { -->
<!--                 district_id <- pt_intersect %>% -->
<!--                     rename(district = DISTRICT) %>% -->
<!--                     mutate(district = as.numeric(district)) -->
<!--                  # ---- Summarize data for MLR ---- -->
<!--                 # mlr_data <- by_admin %>% -->
<!--                 #   group_by(year, district) %>% -->
<!--                 #   mutate( -->
<!--                 #     year          = as.factor(year), -->
<!--                 #     admin_number  = as.integer(round(admin, 0)) -->
<!--                 #   ) %>% -->
<!--                 #   dplyr::filter(!year %in% c(1980, 2013)) %>% -->
<!--                 #   group_by(basin, district, year) %>% -->
<!--                 #   summarise( -->
<!--                 #       short               = sum(short, na.rm = T), -->
<!--                 #       short_dir           = sum(short_dir, na.rm = T), -->
<!--                 #       demand              = sum(demand, na.rm = T), -->
<!--                 #       supply              = sum(supply, na.rm = T), -->
<!--                 #       supply_dir          = sum(supply_dir, na.rm = T) -->
<!--                 #   ) %>% -->
<!--                 #   mutate( -->
<!--                 #       short_norm          = 100*(round(short/demand, 3)), -->
<!--                 #       short_dir_norm      = 100*(round(short_dir/demand, 3)), -->
<!--                 #       aug_supply          = round((supply - supply_dir), 3), -->
<!--                 #       aug_supply_norm     = round(100*(aug_supply/supply), 3), -->
<!--                 #       year                = as.factor(year) -->
<!--                 #   ) -->
<!--                 #  -->
<!--                 # ## ------ Join model data w/ admin level supply/demand/short ------- -->
<!--                 # mlr_district <- left_join( -->
<!--                 #       mlr_data, -->
<!--                 #       dplyr::select(short_year, year = wyear, district, 20:41), -->
<!--                 #       by = c("district", "year") -->
<!--                 # ) %>% -->
<!--                 #   # filter(district == 6) %>% -->
<!--                 #   filter(district == district_id$district) %>% -->
<!--                 #   dplyr::filter(!year %in% c(1980, 2013)) %>% -->
<!--                 #   # group_by(basin, district, water_right, year) %>% -->
<!--                 #   group_by(basin, district, year) %>% -->
<!--                 #   summarise( -->
<!--                 #       short               = sum(short, na.rm = T), -->
<!--                 #       short_dir           = sum(short_dir, na.rm = T), -->
<!--                 #       demand              = sum(demand, na.rm = T), -->
<!--                 #       supply              = sum(supply, na.rm = T), -->
<!--                 #       supply_dir          = sum(supply_dir, na.rm = T), -->
<!--                 #       af_total            = mean(af_total, na.rm = T), -->
<!--                 #       swe_max             = mean(swe_max, na.rm = T), -->
<!--                 #       prcp                = mean(prcp, na.rm = T), -->
<!--                 #       pdsi                = mean(pdsi, na.rm = T), -->
<!--                 #       spi1                = mean(spi1, na.rm = T), -->
<!--                 #       spi3                = mean(spi3, na.rm = T), -->
<!--                 #       spi6                = mean(spi6, na.rm = T), -->
<!--                 #       spi9                = mean(spi9, na.rm = T), -->
<!--                 #       spi12               = mean(spi12, na.rm = T), -->
<!--                 #       tavg                = mean(tavg, na.rm = T), -->
<!--                 #       tmax                = mean(tmax, na.rm = T), -->
<!--                 #       tmin                = mean(tmin, na.rm = T) -->
<!--                 #       ) %>% -->
<!--                 #   mutate( -->
<!--                 #       short_norm          = 100*(round(short/demand, 3)), -->
<!--                 #       short_dir_norm      = 100*(round(short_dir/demand, 3)), -->
<!--                 #       aug_supply          = round((supply - supply_dir), 3), -->
<!--                 #       aug_supply_norm     = round(100*(aug_supply/supply), 3), -->
<!--                 #       year                = as.factor(year) -->
<!--                 #   ) %>% -->
<!--                 #   ungroup() -->

<!--                   district_data <- model_data %>%  -->
<!--                          filter(district == 6) -->
<!--                           # filter(district == district_id$district) -->

<!--                    # ---- log transform data ---- -->
<!--                   mod_df <- district_data %>% -->
<!--                         mutate( -->
<!--                           short               = log10(short), -->
<!--                           short_dir           = log10(short_dir), -->
<!--                           short_norm          = log10(short_norm), -->
<!--                           short_dir_norm      = log10(short_dir_norm), -->
<!--                           aug_supply          = log10(aug_supply), -->
<!--                           aug_supply_norm     = log10(aug_supply_norm), -->
<!--                           supply              = log10(supply), -->
<!--                           supply_dir          = log10(supply_dir), -->
<!--                           demand              = log10(demand), -->
<!--                           af_total            = log10(af_total) -->
<!--                         ) -->
<!--                        # ---- Prep data for model ---- -->
<!--                   mod_df <- mod_df %>% -->
<!--                       # dplyr::select(short_dir_norm, prcp, tavg, tmax, pdsi, spi1, spi3, spi6, spi9, spi12) -->
<!--                       dplyr::select(futureDepVar(),  prcp, tavg, tmax, pdsi, spi1, spi3, spi6, spi9, spi12) -->

<!--                   # replace Infinite w/ 0 -->
<!--                   is.na(mod_df) <- sapply(mod_df, is.infinite) -->
<!--                   mod_df[is.na(mod_df)] <- 0 -->


<!--                   # MLR w/ VIF reduction + stepwise regression -->
<!--                   mlr_vfit <- lm(short_dir_norm~., data = mod_df) %>%  -->
<!--                              ols_step_forward_p() -->

<!--                   # calc VIF -->
<!--                   vf <- car::vif(mlr_vfit$model) -->

<!--                   vf_df <- data.frame(vif = vf) %>%  -->
<!--                     rownames_to_column() %>%  -->
<!--                     filter(vif < 5) -->

<!--                   lm_step <- lm( -->
<!--                                 as.formula(paste("short_dir_norm", paste(vf_df$rowname, collapse=" + "), sep=" ~ ")), -->
<!--                                 data = mod_df)  -->
<!--                   # multivariate stepwise regression -->
<!--                   # lm_run <- lm( -->
<!--                   #   # short_dir_norm~., data = mod_df) %>% -->
<!--                   #               # as.formula( -->
<!--                   #               #   paste0(futureDepVar()," ~ .")), -->
<!--                   #               # data = mod_df) %>% -->
<!--                   #           # rm_collinearity(df = district_data) %>% -->
<!--                   #           ols_step_forward_p()  -->

<!--                   # lm_step <- lm_run$model -->

<!--                   climate_proj <- climate_models %>% -->
<!--                       ungroup() %>% -->
<!--                       filter(district == district_id$district, year > 2020) %>% -->
<!--                       # filter( district == 6, year >2020) %>% -->
<!--                       dplyr::select(-dataset, -year, -district, -pet,-pet_harg, -pdsi_harg) %>% -->
<!--                       mutate(across(where(is.numeric), round, 3)) -->
<!--                       # setNames(c("year", "climate_var")) -->

<!--                   # predict future shorts past 2021 -->
<!--                   pred_future <- predict(lm_step, climate_proj) -->
<!--                   # pred_future <- predict(lm_fit, dplyr::select(climate_proj, aet)) -->
<!--                   pred_df <- data.frame(year = 2021:2099, fitted = pred_future) -->
<!--                    # pred_df <- left_join(pred_df, dplyr::select(future_data, -district), by = "year") -->

<!--                   pred_df <- pred_df %>% -->
<!--                     ungroup() %>% -->
<!--                     mutate( -->
<!--                       prediction          = 10^fitted -->
<!--                     ) %>% -->
<!--                     mutate(across(where(is.numeric), round, 2)) -->

<!--                   current_data <- present_indicators %>%  -->
<!--                     ungroup() %>% -->
<!--                     filter(district == district_id$district) %>% -->
<!--                     # filter(district == 6) %>% -->
<!--                     dplyr::select(-year, -district) %>% -->
<!--                     mutate(across(where(is.numeric), round, 3)) -->

<!--                   # predict current shorts 2013-2020 -->
<!--                   pred_current <- predict(lm_step, current_data) -->
<!--                             # pred_future <- predict(lm_fit, dplyr::select(climate_proj, aet)) -->
<!--                   pred_current_df <- data.frame(year = 2013:2020, fitted = pred_current) -->
<!--                   # pred_df <- left_join(pred_df, dplyr::select(future_data, -district), by = "year") -->
<!--                   pred_current_df <- pred_current_df %>% -->
<!--                     ungroup() %>% -->
<!--                     mutate( -->
<!--                       prediction          = 10^fitted -->
<!--                       ) %>% -->
<!--                     mutate(across(where(is.numeric), round, 2)) -->

<!--                   # indicator_label <- names(clim_model_indicator_lst[grep(pattern = paste0("^", futureClimVar(), "$"), clim_model_indicator_lst)]) -->
<!--                   impact_label <- names(impacts_lst[grep(pattern = paste0("^", futureDepVar(), "$"), impacts_lst)]) -->
<!--                     # indicator_label <- names(clim_model_indicator_lst[grep(pattern = paste0("aet"), clim_model_indicator_lst)]) -->
<!--                     # impact_label <- names(impacts_lst[grep(pattern = paste0("short_dir_norm"), impacts_lst)]) -->


<!--                   # historic impacts -->
<!--                   impact_historic <- district_data %>% -->
<!--                       ungroup() %>% -->
<!--                       dplyr::select(year, futureDepVar()) %>% -->
<!--                       # dplyr::select(year, short_dir_norm) %>% -->
<!--                       mutate( -->
<!--                          year    = as.numeric(as.character(year)), -->
<!--                          source  = "historic" -->
<!--                       ) %>% -->
<!--                       setNames(c("year", "impact", "source")) -->

<!--                   # predicted current impacts -->
<!--                   impact_current <- pred_current_df %>% -->
<!--                       # filter(year > 2020) %>% -->
<!--                       dplyr::select(year, prediction) %>% -->
<!--                       mutate(source = "current") %>% -->
<!--                       setNames(c("year", "impact", "source")) -->

<!--                   # predicted future impacts -->
<!--                   impact_projected <- pred_df %>% -->
<!--                       filter(year > 2020) %>% -->
<!--                       dplyr::select(year, prediction) %>% -->
<!--                       mutate(source = "projected") %>% -->
<!--                       setNames(c("year", "impact", "source")) -->

<!--                   # join historic impacts data w/ predicted impacts -->
<!--                   impact_ts <- bind_rows(impact_historic, impact_current, impact_projected) -->

<!--                   names(lm_step$model) -->
<!--                 # ---- Select predictors from data ---- -->
<!--                 hist_predictors <- district_data %>% -->
<!--                     ungroup() %>% -->
<!--                     dplyr::select(year,  names(lm_step$model)[2:3]) %>% -->
<!--                     mutate(across(where(is.numeric), round, 2)) %>%  -->
<!--                     mutate(year = as.numeric(as.character(year))) -->

<!--                 current_predictors <- present_indicators  %>%  -->
<!--                     ungroup() %>% -->
<!--                     # filter(district == 6) %>% -->
<!--                     filter(district == district_id$district) %>% -->
<!--                     dplyr::select(year,  names(lm_step$model)[2:3]) %>% -->
<!--                     mutate(across(where(is.numeric), round, 2)) %>%  -->
<!--                     mutate(year = as.numeric(as.character(year))) -->

<!--                 future_predictors <- climate_models %>% -->
<!--                     ungroup() %>% -->
<!--                     # filter(district == 6, year > 2020) %>% -->
<!--                     filter(district == district_id$district, year >2020) %>% -->
<!--                     dplyr::select(year, names(lm_step$model)[2:3]) %>% -->
<!--                     # dplyr::select(-dataset, -district, -tmin, -tmax, -pet,-pet_harg, -pdsi_harg) %>% -->
<!--                     mutate(across(where(is.numeric), round, 3)) -->

<!--                 predictor_ts <- bind_rows(hist_predictors, current_predictors, future_predictors) -->
<!--                 # Fix names for axis, labels, titles -->
<!--                 pred_names <- names(dplyr::rename_all(predictor_ts, recode, -->
<!--                                         swe_max           = "SWE maximum (in)", -->
<!--                                         prcp              = "Precipitation (mm)", -->
<!--                                         pdsi              = "PDSI", -->
<!--                                         # pdsi_gridmet      = "PDSI (gridMET)", -->
<!--                                         eddi1             = "EDDI 1 month", -->
<!--                                         eddi3             = "EDDI 3 month", -->
<!--                                         eddi6             = "EDDI 6 month", -->
<!--                                         eddi12            = "EDDI 12 month", -->
<!--                                         spi1              = "SPI 1 month", -->
<!--                                         spi3              = "SPI 3 month", -->
<!--                                         spi6              = "SPI 6 month", -->
<!--                                         spi9              = "SPI 9 month", -->
<!--                                         spi12             = "SPI 12 month", -->
<!--                                         tavg              = "Average temperature (C)", -->
<!--                                         tmax              = "Maximum temperature (C)",     -->
<!--                                         tmin              = "Minimum temperature (C)",         -->
<!--                                         aet               = "Actual evapotranspiration (mm)", -->
<!--                                         pet               = "Potential Evapotranspiration (mm)", -->
<!--                                         soilm             = "Soil moisture (mm)") -->
<!--                                     ) -->
<!--                     # ---- Predictors highchart ---- -->
<!--                 pred_hc <-  -->
<!--                  highchart() %>% -->
<!--                         hc_plotOptions(column = list(stacking = 'normal'), -->
<!--                                        line = list(marker = list(enabled = FALSE), lineWidth = 4)) %>% -->
<!--                         hc_title(text = "Forecasted Water Shortages",   -->
<!--                                  style = list(fontSize = 26, fontWeight = "bold", color = "black")) %>% -->
<!--                       hc_legend(itemStyle = list(fontSize = 18, color = "black", fontWeight = "bold")) %>% -->
<!--                       # hc_xAxis( -->
<!--                       #   categories = district_ts$year, -->
<!--                       #   tickInterval = 2, -->
<!--                       #   labels = list( -->
<!--                       #     y = 30, -->
<!--                       #     style = list(fontSize = 22, color = "black", fontWeight = "bold"))) %>%  -->
<!--                         hc_yAxis_multiples( -->
<!--                             list(title = list( -->
<!--                               text = pred_names[2], -->
<!--                               style = list(fontSize = 24, fontWeight = "bold", color = "black") -->
<!--                             ), -->
<!--                            labels = list(style = list(fontSize = 22, color = "black", fontWeight = "bold")), -->
<!--                             top = "0%", -->
<!--                             height = "33%" -->
<!--                             ), -->
<!--                             list(title = list( -->
<!--                               text   = pred_names[3], -->
<!--                               style  = list(fontSize = 24, fontWeight = "bold", color = "black")), -->
<!--                               labels = list(style = list(fontSize = 22, color = "black", fontWeight = "bold")), -->
<!--                               top      = "33%", -->
<!--                               height = "33%", -->
<!--                               opposite = TRUE) -->
<!--                             , -->
<!--                             list(title = list( -->
<!--                               text   = impact_label, -->
<!--                               style  = list(fontSize = 24, fontWeight = "bold", color = "black")), -->
<!--                               labels = list(style = list(fontSize = 22, color = "black", fontWeight = "bold")), -->
<!--                               top      = "66%", -->
<!--                               height = "33%", -->
<!--                               opposite = F) -->
<!--                           ) %>%       -->
<!--                         hc_xAxis( -->
<!--                             categories = predictor_ts$year, -->
<!--                             tickInterval = 2, -->
<!--                             title = list(text = "Year", style = list(fontSize = 24, color = "black", fontWeight = "bold")), -->
<!--                              labels = list(style = list(fontSize = 22, color = "black", fontWeight = "bold")), -->
<!--                             plotBands = list( -->
<!--                               list(from =1981, to =2020, color = "rgba(0, 100, 0, 0.1)", -->
<!--                                    label = list(text = "Historical record", style = list(fontSize = 16, color = "black", fontWeight = "bold" )))) -->
<!--                           ) %>% -->
<!--                         hc_add_series( -->
<!--                             data = predictor_ts, -->
<!--                             name = pred_names[2], -->
<!--                             type = 'line', -->
<!--                             hcaes(x = year,  y = !!lm_run$predictors[1]), -->
<!--                             yAxis = 0, -->
<!--                             fillOpacity = 0.1) %>% -->
<!--                         hc_add_series( -->
<!--                             data = predictor_ts, -->
<!--                             name = pred_names[3], -->
<!--                             type = 'line', hcaes(x = year, y =  !!lm_run$predictors[2]), -->
<!--                             yAxis = 1, fillOpacity = 0.1) %>% -->
<!--                         hc_add_series( -->
<!--                             data = dplyr::arrange(impact_ts, year), -->
<!--                             type = 'column', name = impact_label, -->
<!--                             # hcaes(x = Independent, y = Dependent), -->
<!--                             hcaes(x = year, y =  impact), -->
<!--                             yAxis = 2, fillOpacity = 0.5) %>% -->
<!--                         hc_xAxis(categories = predictor_ts$year) %>% -->
<!--                         hc_colors(c("darkblue",  "darkred", "black")) %>% -->
<!--                         hc_chart(plotBorderWidth = 0.5, plotBorderColor = '#b4b4b4', height = NULL) -->
<!--                 pred_hc -->
<!--                 # # ---- MLR Model + stepwise regression ---- -->

<!--              } -->
<!--    }) -->

<!-- output$MLRpredictionPlot <- highcharter::renderHighchart({ -->
<!--   MLRpredictionData() -->
<!-- }) -->
<!-- ``` -->


<!-- ### Model summary {data-height=50} -->
<!-- ```{r} -->
<!-- # formattable::formattableOutput("futureModelSummary") -->
<!-- reactable::reactableOutput("futureModelSummary") -->
<!-- bsPopover("futureModelSummary", title = "Model Summary", content = "This is a summary table containing the coefficients and R Squared for the multiple linear regression model used for forecasting shortages using the MACA climate model dataset",placement = "left", options = list(container = "body")) -->
<!-- # bsTooltip("futureModelSummary", "INSERT TEXT HERE", -->
<!-- #                     "top", options = list(container = "body")) -->
<!-- tags$style(HTML(" -->
<!--                 .tooltip > .tooltip-inner { -->
<!--                 width: 400px; -->
<!--                 color: black; -->
<!--                 background-color: white; -->
<!--                 } -->
<!--                 ")) -->

<!-- ``` -->

```{r context = "server"}
# futureModelSummaryData <- eventReactive(input$submitButton2, {
#    # if(!is.null(input$districtMapFuture_click)) {
#     click <- input$districtMapFuture_click %>%
#             data.frame() %>%
#             dplyr::select(lat,lng)
# 
#           pt <- sf::st_as_sf(
#             click,
#             coords = c("lng", "lat"),
#             crs = 4326
#             )
#           # point intersection w/ polygons
#           pt_intersect <-  st_filter(shp, pt)
# 
#           # ensure  app will not crash if a somewhere other than a shape is clicked and returns no results from point-shape intersection
#           if(nrow(pt_intersect) == 0) {
#               NULL
#              } else {
#                 district_id <- pt_intersect %>%
#                     rename(district = DISTRICT) %>%
#                     mutate(district = as.numeric(district))
                 # ---- Water supply data summarized to the year ----
                # ws_data <- by_admin %>%
                #   group_by(year, district) %>%
                #   mutate(
                #       year          = as.factor(year),
                #       admin_number  = as.integer(round(admin, 0))
                #   ) %>%
                #   dplyr::filter(!year %in% c(1980, 2013)) %>%
                #   group_by(basin, district, year) %>%
                #   summarise(
                #       short               = sum(short, na.rm = T),
                #       short_dir           = sum(short_dir, na.rm = T),
                #       demand              = sum(demand, na.rm = T),
                #       supply              = sum(supply, na.rm = T),
                #       supply_dir          = sum(supply_dir, na.rm = T)
                #   ) %>%
                #   mutate(
                #       short_norm          = 100*(round(short/demand, 3)),
                #       short_dir_norm      = 100*(round(short_dir/demand, 3)),
                #       aug_supply          = round((supply - supply_dir), 3),
                #       aug_supply_norm     = round(100*(aug_supply/supply), 3),
                #       year                = as.factor(year)
                #   )
                # 
                # # ---- Join indicators & impacts data, summarize to district level ----
                # by_district <- left_join(
                #       ws_data,
                #       dplyr::select(short_year, year = wyear, district, 20:41),
                #       by = c("district", "year")
                # ) %>%
                #   # filter(district == 9) %>%
                #   filter(district == district_id$district) %>%
                #   dplyr::filter(!year %in% c(1980, 2013)) %>%
                #   group_by(basin, district, year) %>%
                #   summarise(
                #         short               = sum(short, na.rm = T),
                #         short_dir           = sum(short_dir, na.rm = T),
                #         demand              = sum(demand, na.rm = T),
                #         supply              = sum(supply, na.rm = T),
                #         supply_dir          = sum(supply_dir, na.rm = T),
                #         af_total            = mean(af_total, na.rm = T),
                #         swe_max             = mean(swe_max, na.rm = T),
                #         prcp                = mean(prcp, na.rm = T),
                #         prcp_norm           = mean(prcp_norm, na.rm = T),
                #         # pdsi                = mean(pdsi, na.rm = T),
                #         pdsi                = mean(pdsi_gridmet, na.rm = T),
                #         eddi1               = mean(eddi1, na.rm = T),
                #         eddi3               = mean(eddi3, na.rm = T),
                #         eddi6               = mean(eddi6, na.rm = T),
                #         eddi12              = mean(eddi12, na.rm = T),
                #         spi1                = mean(spi1, na.rm = T),
                #         spi3                = mean(spi3, na.rm = T),
                #         spi6                = mean(spi6, na.rm = T),
                #         spi9                = mean(spi9, na.rm = T),
                #         spi12               = mean(spi12, na.rm = T),
                #         tavg                = mean(tavg, na.rm = T),
                #         aet                 = mean(aet, na.rm = T),
                #         pet                 = mean(pet, na.rm = T),
                #         soilm               = mean(soilm, na.rm = T)
                #   ) %>%
                #   mutate(
                #         short_norm          = 100*(round(short/demand, 3)),
                #         short_dir_norm      = 100*(round(short_dir/demand, 3)),
                #         aug_supply          = round((supply - supply_dir), 3),
                #         aug_supply_norm     = round(100*(aug_supply/supply), 3),
                #         year                = as.factor(year)
                #   )
                # # ---- log transform data ----
                # mod_df <- by_district %>%
                #       mutate(
                #         short               = log10(short),
                #         short_dir           = log10(short_dir),
                #         short_norm          = log10(short_norm),
                #         short_dir_norm      = log10(short_dir_norm),
                #         aug_supply          = log10(aug_supply),
                #         aug_supply_norm     = log10(aug_supply_norm),
                #         supply              = log10(supply),
                #         supply_dir          = log10(supply_dir),
                #         demand              = log10(demand)
                #       ) %>% ungroup()

                # replace Infinite w/ 0
                # is.na(trans_log) <- sapply(trans_log, is.infinite)
                # trans_log[is.na(trans_log)] <- 0

                # trans_log <- trans_log %>%
                #       # dplyr::select(short_dir_norm, prcp)
                #       dplyr::select(futureDepVar(), futureClimVar())
                
                # # ---- Prep data for model ----
                # district_data <- model_data %>% 
                #          # filter(district == 6)
                #           filter(district == district_id$district)
                #   
                #    # ---- log transform data ----
                #   mod_df <- district_data %>%
                #         mutate(
                #           short               = log10(short),
                #           short_dir           = log10(short_dir),
                #           short_norm          = log10(short_norm),
                #           short_dir_norm      = log10(short_dir_norm),
                #           aug_supply          = log10(aug_supply),
                #           aug_supply_norm     = log10(aug_supply_norm),
                #           supply              = log10(supply),
                #           supply_dir          = log10(supply_dir),
                #           demand              = log10(demand),
                #           af_total            = log10(af_total)
                #         )
                #        # ---- Prep data for model ----
                #   mod_df <- mod_df %>%
                #       # dplyr::select(short_dir_norm, prcp, tavg, tmax, pet, pdsi, spi1, spi3, spi6, spi9, spi12)
                #        dplyr::select(futureDepVar(),  prcp, tavg, tmax, pet, pdsi, spi1, spi3, spi6, spi9, spi12)
              #   # filter model data to clicked District
              #   district_data <- model_data %>% 
              #       # filter(district == 6) 
              #      filter(district == district_id$district)
              #   
              #   # subset and log transform data for MLR
              #     log_trans <- district_data %>%
              #       mutate(
              #             short               = log10(short),
              #             short_dir           = log10(short_dir),
              #             short_norm          = log10(short_norm),
              #             short_dir_norm      = log10(short_dir_norm),
              #             aug_supply          = log10(aug_supply),
              #             aug_supply_norm     = log10(aug_supply_norm),
              #             supply              = log10(supply),
              #             supply_dir          = log10(supply_dir),
              #             demand              = log10(demand),
              #             af_total            = log10(af_total)
              #           ) %>% 
              #           ungroup() %>% 
              #            dplyr::select(
              #         futureDepVar(), prcp, tavg, tmax, pdsi, spi1, spi3, spi6, spi9,
              #         spi12, pet
              #         )
              #       # dplyr::select(
              #       #   short_dir_norm, prcp, tavg, tmax, pdsi, spi1, spi3, spi6, spi9,
              #       #   spi12, pet
              #       #   )
              #     
              #     #     # replace Infinite w/ 0
              #     is.na(log_trans) <- sapply(log_trans, is.infinite)
              #     log_trans[is.na(log_trans)] <- 0
              #     # replace Infinite w/ 0
              #     # is.na(mod_df) <- sapply(mod_df, is.infinite)
              #     # mod_df[is.na(mod_df)] <- 0
              #     
              #     # multivariate stepwise regression
              #     lm_run <- lm(
              #       # short_dir_norm~., data = log_trans) %>%
              #                   as.formula(
              #                     paste0(futureDepVar()," ~ .")),
              #                   data = log_trans) %>%
              #               # rm_collinearity(df = log_trans) %>%
              #               ols_step_forward_p() 
              #   
              #   
              #     lm_model  <-  lm_run$model 
              # 
              #     results   <-  augment(lm_model)
              #     tidied    <-  tidy(lm_model)
              #     metrics   <-  glance(lm_model)
              #     
              #     rsq_pval    <-  metrics %>% 
              #         dplyr::select(r_squared = r.squared, p_value = p.value) %>% 
              #         mutate(across(where(is.numeric), round, 3))
              #         # pivot_longer(cols = c(1:2)) %>% 
              #         # setNames(c("term", "estimate"))
              #     
              #     coeff  <-  tidied %>% 
              #         dplyr::select(term, estimate) %>% 
              #         mutate(across(where(is.numeric), round, 3)) %>% 
              #         pivot_wider(names_from = "term", values_from = "estimate")
              #     
              #     
              #     tbl_all <- bind_cols(coeff, rsq_pval)
              #   
              #     # recode names
              #     clean_names <- names(rename_all(tbl_all, recode,
              #                                    "(Intercept)"     = "Intercept", 
              #                                    r_squared         = "R2",
              #                                    p_value           = "p-value",
              #                                    swe_max           = "SWE maximum",
              #                                    prcp              = "Precipitation",
              #                                    pdsi              = "PDSI",
              #                                    # pdsi_gridmet      = "PDSI (gridMET)",
              #                                    eddi1             = "EDDI 1 month",
              #                                    eddi3             = "EDDI 3 month",
              #                                    eddi6             = "EDDI 6 month",
              #                                    eddi12            = "EDDI 12 month",
              #                                    spi1              = "SPI 1 month",
              #                                    spi3              = "SPI 3 month",
              #                                    spi6              = "SPI 6 month",
              #                                    spi9              = "SPI 9 month",
              #                                    spi12             = "SPI 12 month",
              #                                    tavg              = "Average Temperature",
              #                                    tmax              = "Maximum temperature",    
              #                                    tmin              = "Minimum temperature",        
              #                                    aet               = "Actual evapotranspiration",
              #                                    pet               = "PET",
              #                                    soilm             = "Soil moisture (mm)")
              #                          )
              #   
              #   tbl_clean <-  tbl_all %>% setNames(clean_names)
              #     rsq_colors <- data.frame("R squared" = c(0, 1))
              # 
              # # Clean reactable table 
              # tbl_react <- reactable(
              #   tbl_clean,
              #   style = list(fontFamily = "Work Sans, sans-serif", fontSize = "14px", fontWeight = 600),
              #   defaultColDef = colDef(
              #     align = "center",
              #     style = pos_neg_colors("red", "green", bold = TRUE)),
              #   columns = list(
              #     "R2" = colDef(
              #       style = color_scales(rsq_colors, span = TRUE, colors = c("#FFFFcc", "#4c9900"), 
              #                            opacity = .7, bold_text = T,
              #                            text_color = "black", 
              #                            brighten_text_color = "black"),
              #     ),
              #     "Intercept" = colDef(
              #         style = pos_neg_colors("black", "black", bold = TRUE)
              #     )),
              #       # style = pos_neg_colors("red", "green", bold = TRUE))
              #     # ),
              #   highlight = TRUE,
              #   # outlined = T,
              #   # bordered = T,
              #   # compact = T, 
              #   theme = reactableTheme( 
              #     borderColor = "black",
              #     # cellStyle = list(display = "flex", flexDirection = "column", justifyContent = "center"),
              #     headerStyle = list(
              #       backgroundColor = "hsl(207, 16%, 80%)"),
              #     )
              #   ) 
              #   # add_subtitle("Model Results", align = "center",  font_size = 16, margin = 3)
              #   
              #   # reactive model summary table
              #   tbl_react
                
                # tbl_clean %>% pivot_longer(cols = c(1:ncol(tbl_clean)))
                # tbl_long <- tbl_clean %>%
                #   pivot_longer(cols = c(1:ncol(tbl_clean))) %>% 
                #   setNames(c("Metric", "Value")) %>% 
                #   mutate(
                #     Type = case_when(
                #       Metric %in% c("R squared", "p-value") ~ "Metrics",
                #       !Metric %in% c("R squared", "p-value") ~ "Coefficients"
                #     )
                #   )
                
                # Clean reactable table 
                # tbl_react <- reactable(
                #   tbl_clean,
                #   style = list(fontFamily = "Work Sans, sans-serif", fontSize = "14px"),
                #   defaultColDef = colDef(
                #    style = function(value) {
                #               color <- if (value > 0) {
                #                 "#008000"
                #               } else if (value < 0) {
                #                 "#e00000"
                #               }
                #               list(
                #                 # background = color, 
                #                 fontWeight = 600,
                #                 color = color
                #                 )
                #     # style = function(value) {
                #     #     if (!is.numeric(value)) return()
                #     #     normalized <- (value - min(nottem)) / (max(nottem) - min(nottem))
                #     #     color <- BuYlRd(normalized)
                #     #     list(background = color)
                #         }
                #     # style = pos_neg_colors("red", "green", bold = TRUE)
                #     ),
                #   # columns = list(
                #   #   Intercept = colDef(
                #   #     style = pos_neg_colors("red", "green", bold = TRUE))
                #   #   ),
                #   highlight = TRUE,
                #   outlined = T,
                #   bordered = T,
                #   compact = T
                #   )
                # tbl_react
                # Clean reactable table 
              # tbl_react_long <- reactable(
              #       tbl_long,
              #       groupBy = "Type",
              #       style = list(fontFamily = "Work Sans, sans-serif", fontSize = "14px", fontWeight = 600),
              #       defaultColDef = colDef(
              #         align = "center",
              #         style = pos_neg_colors("red", "green", bold = TRUE)),
              #       highlight = TRUE,
              #       outlined = T,
              #       bordered = T,
              #       compact = T, 
              #       theme = reactableTheme( 
              #         borderColor = "black",
              #         cellStyle = list(display = "flex", flexDirection = "column", justifyContent = "center"),
              #         headerStyle = list(
              #           backgroundColor = "hsl(207, 16%, 80%)"),
              #       
              #         ),# defaultExpanded = TRUE
              #       ) %>% 
              #       add_subtitle("Model Results",align = "center",  font_size = 26, margin = 4)
              # tbl_react_long
              
        
                # lm_run <- trans_log %>%
                #         group_by(district) %>%
                #         nest(-district) %>%
                #         mutate(
                #           fit       = map(data,
                #                            # ~lm(short_dir_norm~prcp, data = .)),
                #                            ~lm(as.formula(
                #                              paste(futureDepVar()," ~ ", futureClimVar())
                #                            ),
                #                            data = .)),
                #           results   = map(fit, augment),
                #           tidied    = map(fit, tidy),
                #           metrics   = map(fit, glance)
                #         )
                # 
                #  indicator_label <- names(clim_model_indicator_lst[grep(pattern = paste0("^", futureClimVar(), "$"), clim_model_indicator_lst)])
                #  impact_label <- names(impacts_lst[grep(pattern = paste0("^", futureDepVar(), "$"), impacts_lst)])
                #  # indicator_label <- names(clim_model_indicator_lst[grep(pattern = paste0("prcp"), clim_model_indicator_lst)])
                #  # impact_label <- names(impacts_lst[grep(pattern = paste0("short_dir_norm"), impacts_lst)])
                # 
                #  tbl_data <- lm_run %>%
                #         unnest(c(metrics)) %>%
                #         dplyr::select(district, tidied, r_squared = r.squared, p_value = p.value) %>%
                #         unnest(c(tidied))  %>%
                #         ungroup() %>%
                #         dplyr::select(term, coefficient = estimate, r_squared, p_value) %>%
                #         mutate(
                #             coefficient   = round(coefficient, 3),
                #             r_squared     = round(r_squared,3),
                #             p_value       = round(p_value, 5)
                #                ) %>%
                #         # mutate(across(where(is.numeric), round, 3)) %>%
                #         # mutate(across(where(is.numeric), as.character)) %>%
                #         rename(
                #             # District      = district,
                #             Term          = term,
                #             Coefficient   = coefficient,
                #             "R Squared"   = r_squared,
                #             "p-value"     = p_value
                #         )
                #   tbl_coeff <- tbl_data %>% 
                #         filter(Term != "(Intercept)") %>% 
                #         mutate(
                #            Term = indicator_label
                #            )
                #    
                #   tbl_int <- tbl_data %>% 
                #         filter(Term == "(Intercept)") 
                # 
                #   tbl_clean <- bind_rows(tbl_int, tbl_coeff)
                #    
                #   customGreen0 = "#DeF7E9"
                #   customGreen = "#71CA97"
                #   customRed = "#ff7f7f"
                #   improvement_formatter <-
                #         formatter("span",
                #                   style = x ~ style(
                #                     font.weight = "bold",
                #                     color = ifelse(x > 0, customGreen, ifelse(x < 0, customRed, "black"))
                #                     )
                #                   )
                #   format_tbl <-
                #     formattable(tbl_clean,
                #                 align = c("l",rep("r", NCOL(tbl_data) - 1)),
                #                 list(
                #                   `Term` = formatter("span", style = ~ style(color = "black", font.weight = "bold")),
                #                   `Coefficient` = improvement_formatter,
                #                   area(col = 3:4) ~ color_tile("#EAECEE", "#EAECEE"))
                #                 )
                #   format_tbl
          #       }
          # })

# output$futureModelSummary <- renderFormattable({
#                   futureModelSummaryData()
#                   })
# output$futureModelSummary <- reactable::renderReactable({
#                   futureModelSummaryData()
#                   })
```








