---
title: "CPO"
runtime: shiny
output: 
  flexdashboard::flex_dashboard:
    css: custom.css
    navbar:
      - { icon: "fa-question-circle", href: "https://anguswg-ucsb.github.io/home_page/", align: right }
    theme: cerulean
    orientation: columns
    vertical_layout: fill
---

```{r setup, include = FALSE}
# Shiny & Flexdashboard libraries

# Shiny & Flexdashboard packages
library(shiny)
library(flexdashboard)

# Data manipulation
library(tidyr)
library(dplyr)

# Mapping packages
library(leaflet)
library(sf)

# Plotting packages
library(highcharter)
library(formattable)
library(reactable)
library(reactablefmtr)
library(viridisLite)
library(RColorBrewer)

# Tool tips & Modals
library(shinyalert)
library(shinyBS)
library(aws.s3)

# --- Shiny utils ---
basemap <- function(shp, pts = NULL) {

    leaflet() %>%
          addProviderTiles(providers$Esri.NatGeoWorldMap, group = "Nat Geo Topographic2") %>%
          addPolygons(
              data = shp,
              fillColor = 'white',
              # fillColor = 'grey',
              # fillColor = ~pal_fact(BASIN),
              fillOpacity = 0.7,
              col = "black",
              opacity = 1,
              weight = 2.5,
              label = ~paste0("District  ", DISTRICT),
              layerId = ~DISTRICT,
              labelOptions = labelOptions(
                  noHide = F,
                  # direction = 'center',
                  # textOnly = F)
                  style = list(
                    "color" = "black",
                    "font-weight" = "1000")
                  )
              ) %>%
          addScaleBar("bottomleft") %>%
          # leafem::addMouseCoordinates() %>%
          leaflet::setView(lng = -105.6, lat = 39.7, zoom = 6)

}

# Leaflet map with MLR metrics as district colors
mlr_map <- function(shp, pts = NULL) {

  # Variance * R2 colors (normalized)
  pal <- colorNumeric(viridisLite::magma(n = 30, direction = -1), domain = shp$var_sensitivity_norm, reverse = F, n = 30)


      # Leaflet map
      leaflet() %>%
        addProviderTiles(providers$Esri.NatGeoWorldMap, group = "Nat Geo Topographic") %>%
        addPolygons(
          data = shp,
          color = "black",
          opacity = 1,
          fillOpacity = 0.7,
          fillColor = ~pal(var_sensitivity_norm),
          weight = 2,
          label = ~paste0("District  ", DISTRICT),
          layerId = ~DISTRICT,
          labelOptions = labelOptions(
            noHide = F,
            # direction = 'center',
            # textOnly = F)
            style = list(
              "color" = "black",
              "font-weight" = "1000")
          )
        ) %>%
        addLegend(
          data = shp,
          "bottomright",
          pal = pal,
          values = ~var_sensitivity_norm,
          title = "Climate sensitivity",
          labFormat = labelFormat(digits = 10,),
          opacity = 1
        ) %>%
        addScaleBar("bottomleft") %>%
        # leafem::addMouseCoordinates() %>%
        leaflet::setView(lng = -105.6, lat = 39.7, zoom = 6)

}

# Map mean annual direct flow shortage as % of demand
ep_map <- function(shp, pts = NULL) {

  # values 0 - 100%
  vect = seq(0, 100, 10)

  # binned colors of mean annual direct flow shortage as % of demand
  binpal <- colorBin(
                    "Spectral",
                    domain  = vect,
                    n       = 4,
                    reverse = T,
                    pretty  = T
                    )

  # Node type legend
  node_type_label     <- c("Agricultural", "Municipal")
  node_type_pal       <- colorFactor(
                                    c("red", "dodgerblue"),
                                    domain = node_type_label,
                                    reverse = F
                                  )

  # Leaflet map
  leaflet() %>%
    addProviderTiles(providers$Esri.NatGeoWorldMap, group = "Nat Geo Topographic") %>%
    addPolygons(
      data        = shp,
      color       = "black",
      opacity     = 1,
      fillOpacity = 0.7,
      fillColor   = ~binpal(mean_short_dir),
      weight      = 2,
      label       = ~paste0("District  ", DISTRICT),
      layerId     = ~DISTRICT,
      labelOptions = labelOptions(
        noHide = F,
        style  = list(
          "color" = "black",
          "font-weight" = "1000"))
    ) %>%
    addLegend(
      data    = shp,
      "bottomright",
      pal     = binpal,
      values  = ~vect,
      opacity = 1,
      title   = "Direct Flow Shortage",
      labFormat = labelFormat(
        digits = 10,
        suffix = " % of demand")
    )  %>%
    addScaleBar("bottomleft") %>%
    addLegend(
      pal       = node_type_pal,
      position  = "bottomleft",
      values    = node_type_label,
      # title     = "Node Type",
      group     = "Nodes",
      layerId   = "node_id") %>%
    leaflet::setView(lng = -105.6, lat = 39.7, zoom = 6)
}

# coeff_map <- function(shp, pts)
# custom highcharter theme
custom_theme <- hc_theme_merge(
  hc_theme_elementary(),
  hc_theme(
    chart = list(
      style = list(
        # fontFamily = "Montserrat"
        fontFamily = "Helvetica"
        # fontFamily = "Arial"
      )
    ),
    subtitle = list(
      style = list(
        # fontFamily = "Montserrat"
        fontFamily = "Helvetica"
        # fontFamily = "Arial"
      )
    ),
    legend = list(
      itemStyle = list(
        fontFamily = "Helvetica"
      )),
    title = list(
      style = list(
        fontFamily = "Helvetica"
      )
    )
  )
)

plot_fitted <- function(fitted_data) {

  hc_plot <-
    highchart() %>%
      hc_plotOptions(
        line    = list(marker = list(enabled = FALSE), lineWidth = 5),
        scatter = list(marker = list(symbol = "circle", radius = 3))
      )%>%
      hc_title(
        text   = "Model Performance",
        style   = list(fontSize = 20, fontWeight = "bold", color = "black")) %>%
      hc_yAxis(
        tickInterval = 20,
        min          = 0,
        max          = 100,
        title        = list(
          text   = "Statemod (Observed)", # margin = 60,
          style  = list(fontSize = 14, fontWeight = "bold", color = "black")),
        labels       = list(
          format = "{value} %",
          y      = 10,
          style  = list(fontSize = 16, color = "black", fontWeight = "bold"))) %>%
      hc_xAxis(
        tickInterval = 20,
        min          = 0,
        max          = 100,
        title        = list(
          text   = "Climate Regression Simulated", # margin = 60,
          style  = list(fontSize = 14, fontWeight = "bold", color = "black")),
        labels       = list(
          format = "{value} %",
          y      = 35,
          style  = list(fontSize = 16, color = "black", fontWeight = "bold"))) %>%
      # hc_annotations( list( labels = list(list(point = list(x = 22, y = 22, xAxis = 0, yAxis = 0), text = "x: {rsquared}")))) %>%
      hc_add_series(
        data         = fitted_data,
        name         = "Prediction",
        type         = 'point',
        yAxis        = 0,
        fillOpacity  = 0.5,
        hcaes(
          x  = Fitted,
          y  =  `Direct flow shortage normalized`)) %>%
      hc_add_series(
        data         = fitted_data,
        name         = "One to one line",
        type         = 'line',
        yAxis        = 0,
        fillOpacity  = 0.5,
        hcaes(
          x  = `Direct flow shortage normalized`,
          y  =  `Direct flow shortage normalized`)
        ) %>%
    hc_add_theme(custom_theme) %>%
    # hc_add_theme(hc_theme_elementary()) %>%
    hc_colors(c("#70BCE2", "black")) %>%
    hc_chart(
      plotBorderWidth = 0.5,
      plotBorderColor = '#b4b4b4',
      height          = NULL)

      return(hc_plot)
}

plot_water_ts <- function(df) {
  water_ts_plot <-
      highchart() %>%
            hc_plotOptions(
              column = list(stacking = 'normal'),
              line   = list(marker = list(enabled = FALSE), lineWidth = 5)) %>%
            hc_title(
              text   = "Timeseries of district-level demand, direct-flow supply, and shortages",
              style   = list(fontSize = 20, fontWeight = "bold", color = "black")) %>%
            hc_yAxis(
              min      = 0,
              title    = list(
                          text   = "Water volume (AF)",
                          style  = list(fontSize = 14, fontWeight = "bold", color = "black")),
              labels   = list(
                          y      = 10,
                          style  = list(fontSize = 16, color = "black", fontWeight = "bold"))) %>%
            hc_xAxis(
              # categories    = ws_wide$year,
              categories    = df$year,
              tickInterval  = 2,
              labels   = list(
                          y      = 35,
                          style  = list(fontSize = 16, color = "black", fontWeight = "bold"))) %>%
            hc_add_series(
              # data        = ws_wide,
              data        = df,
              name        = "Total shortage",
              type        = 'column',
              tooltip     = list(pointFormat = "Total shortage: {point.short} AF"),
              fillOpacity = 0.3,
              hcaes(
                x  = year,
                y  = short
                )
              ) %>%
            hc_add_series(
              # data        = ws_wide,
              data        = df,
              name        = "Augmented supply",
              type        = 'column',
              tooltip     = list(pointFormat = "Augmented supply: {point.Supply Augmented} AF"),
              fillOpacity = 0.3,
              hcaes(
                x  = year,
                y  = `Supply Augmented`
                )
              ) %>%
            hc_add_series(
              # data        = ws_wide,
              data        = df,
              name        = "Direct Flow Supply",
              type        = 'column',
              tooltip     = list(pointFormat = "Direct Flow Supply: {point.Supply Direct flow} AF"),
              fillOpacity = 0.3,
              hcaes(
                x  = year,
                y  = `Supply Direct flow`)) %>%
            hc_add_series(
              # data        = ws_wide,
              data        = df,
              name        = "Demand",
              type        = 'line',
              tooltip     = list(pointFormat = "Demand: {point.Demand} AF"),
              hcaes(
                x  = year,
                y  = Demand
                )
              ) %>%
            hc_add_theme(custom_theme) %>%
            # hc_add_theme(hc_theme_elementary()) %>%
            hc_colors(c("#E18686",  "#70BCE2", "#2984B2", "black")) %>%
            hc_chart(
              plotBorderWidth = 0.5,
              plotBorderColor = '#b4b4b4',
              height          = NULL)
  return(water_ts_plot)
}

plot_mlr_predictors <- function(predictors, names, number_vars = 2) {

  # names <- plot_labels
  # predictors <- predictors_data
  if(number_vars == 2) {

      predictors_ts_plot <-
          highchart() %>%
              hc_plotOptions(
                column = list(stacking = 'normal'),
                line = list(marker = list(enabled = FALSE), lineWidth = 5)) %>%
              hc_title(
                text   = "Best climate predictors of shortages",
                style   = list(fontSize = 20, fontWeight = "bold", color = "black")) %>%
              hc_yAxis_multiples(
                list(title     = list(
                  # text      = name_df$clean_name[1],
                  # text      =  filter(name_df, var == names(ws_predictors)[2])$clean_name,
                  text      =  filter(names, var == names(predictors)[2])$clean_name,
                  style     = list(fontSize = 14, color = "black", fontWeight = "bold")),
                  labels    = list(
                    style      = list(fontSize = 16, color = "black", fontWeight = "bold")),
                  top    = "0%",
                  height = "50%"),
                list(title     = list(
                  # text      = name_df$clean_name[2],
                  # text      =  filter(name_df, var == names(ws_predictors)[3])$clean_name,
                  text      =  filter(names, var == names(predictors)[3])$clean_name,
                  style     = list(fontSize = 14, color = "black", fontWeight = "bold")),
                  labels   = list(
                    style     = list(fontSize = 16, color = "black", fontWeight = "bold")),
                  top       = "50%",
                  height    = "50%",
                  opposite  = TRUE,
                  y         = 35)) %>%
              hc_xAxis(
                tickInterval  = 2,
                y             = 35,
                categories    = predictors$year,
                labels        = list(style = list(fontSize = 16, color = "black", fontWeight = "bold"))) %>%
              hc_add_series(
                data        = predictors,
                # name = name_df$clean_name[1],
                name        = filter(names, var == names(predictors)[2])$clean_name,
                type        = 'line',
                yAxis       = 0,
                fillOpacity = 0.1,
                hcaes(
                  x = year,
                  y = !!names(predictors)[2])
                ) %>%
              hc_add_series(
                data        = predictors,
                name        = filter(names, var == names(predictors)[3])$clean_name,
                type        = 'line',
                yAxis       = 1,
                fillOpacity = 0.1,
                hcaes(
                  x = year,
                  y = !!names(predictors)[3])
                  ) %>%
              hc_add_theme(custom_theme) %>%
              # hc_add_theme(hc_theme_elementary()) %>%
              hc_colors(c("darkblue",  "darkred")) %>%
              hc_chart(
                plotBorderWidth = 0.5,
                plotBorderColor = '#b4b4b4',
                height          = NULL)
      return(predictors_ts_plot)
  } else {
    predictors_ts_plot <-
          highchart() %>%
              hc_plotOptions(
                column = list(stacking = 'normal'),
                line = list(marker = list(enabled = FALSE), lineWidth = 5)) %>%
              hc_title(
                text   = "Best climate predictors of shortages in district",
                style   = list(fontSize = 20, fontWeight = "bold", color = "black")) %>%
              hc_yAxis(title     = list(
                text      =  filter(names, var == names(predictors)[2])$clean_name,  # text   =  filter(name_df, var == names(ws_predictors)[2])$clean_name,
                style     = list(fontSize = 14, color = "black", fontWeight = "bold")),
                labels    = list(
                  style      = list(fontSize = 16, color = "black", fontWeight = "bold"))) %>%
              hc_xAxis(
                tickInterval  = 2,
                y             = 35,
                categories    = predictors$year,  # categories    = ws_predictors$year,
                labels        = list(style = list(fontSize = 16, color = "black", fontWeight = "bold"))) %>%
              hc_add_series(
                data        = predictors,  # data = ws_predictors,
                name        = filter(names, var == names(predictors)[2])$clean_name, # name = filter(name_df, var == names(ws_predictors)[2])$clean_name,
                type        = 'line',
                yAxis       = 0,
                fillOpacity = 0.1,
                hcaes(
                  x = year,
                  # y = !!names(ws_predictors)[2])
                  y = !!names(predictors)[2])
              ) %>%
              hc_colors(c("darkblue")) %>%
              hc_chart(plotBorderWidth = 0.5, plotBorderColor = '#b4b4b4', height = NULL)

    return(predictors_ts_plot)
  }
}
# plot_mlr_predictors(predictors = ws_predictors, names = name_df, number_vars = 1)


plot_lm_density <- function(df, dep_label, ind_label) {

  # Values for Y axis of density plot
  density_yaxis  <- density(df$Independent)$y

  lm_density_plot <-
    highchart() %>%
          hc_plotOptions(line = list(marker = list(enabled = FALSE, symbol = "circle"), lineWidth = 5),
                         scatter = list(marker = list(symbol = "circle", radius = 5))) %>%
          hc_title(
            text   = "Linear Regression Model",
            style   = list(fontSize = 20, fontWeight = "bold", color = "black")) %>%
          hc_yAxis_multiples(
            list(
              title  = list(
                        text  = "",
                        style = list(fontSize = 16, fontWeight = "bold", color = "black")),
              labels = list(
                        style = list(fontSize = 16, color = "black", fontWeight = "bold")),
              min    = 0,
              y      = 40,
              max    = max(density_yaxis),
              opposite = TRUE),
            list(
              title  = list(
                        text  = dep_label,
                        style = list(fontSize = 16, fontWeight = "bold", color = "black")),
              labels = list(
                        style = list(fontSize = 16, color = "black", fontWeight = "bold")),
              min    = 0,
              y      = 40,
              max    = max(df$Dependent))) %>%
          hc_xAxis(
            title = list(
              text = ind_label,
              style = list(fontSize = 16, fontWeight = "bold", color = "black")),
            labels = list(style = list(fontSize = 16, color = "black", fontWeight = "bold"))
          ) %>%
          hc_legend(itemStyle = list(fontSize = 16, color = "black", fontWeight = "bold")) %>%
          hc_add_series(
            data = density(df$Independent),
            # data = density(mod_vals$!!climVar()),
            type = 'area',
            name = "Climate variable distribution",
            # name = paste0(ind_label, " distribution"),
            yAxis = 0,
            fillOpacity = 0.8) %>%
          hc_add_series(
            data = dplyr::arrange(df, Independent),
            # data = dplyr::arrange(mod_vals, `Precipitation`),
            type = 'scatter',
            name = "Observed",
            # hcaes(x = Independent, y = Dependent),
            # hcaes(x = `Precipitation`, y =  `Normalized direct shortage`),
            hcaes(x = Independent, y =  Dependent),
            yAxis = 1,
            fillOpacity = 0.5) %>%
          hc_add_series(
            data = dplyr::arrange(df, Independent),
            # data = dplyr::arrange(mod_vals, !!climVar()),
            type = 'line',
            name = "Fitted",
            # hcaes(x = `Precipitation`, y = Fitted),
            hcaes(x = Independent, y = Fitted),
            yAxis = 1,
            fillOpacity = 0.5
          )  %>%
          hc_add_theme(custom_theme) %>%
          # hc_add_theme(hc_theme_elementary()) %>%
          hc_colors(c("#91BEEA", "#34495E", "black")) %>% # "#5D6D7E"
          hc_chart(plotBorderWidth = 0.5, plotBorderColor = '#b4b4b4', height = NULL)

  return(lm_density_plot)
}

# formatabble table/colors
customGreen0 <-  "#DeF7E9"
customGreen  <-  "#71CA97"
customRed    <-  "#ff7f7f"

improvement_formatter <-
  formatter("span",
            style = x ~ style(
              font.weight = "bold",
              color = ifelse(x > 0, customGreen, ifelse(x < 0, customRed, "black"))
            )
  )

plot_right_short <- function(df_list) {
# df_list <- node_split_short
  right_short_plot <-
        highchart() %>%
              hc_plotOptions(
                # series = list(label = list(enabled = FALSE)),
                line   = list(marker    = list(
                                  enabled = FALSE, symbol = "circle"),
                              label     = list(enabled = FALSE),
                              lineWidth = 4),
                area   = list(stacking  = 'normal',
                              marker    = list(enabled = FALSE),
                              label     = list(enabled = FALSE)),
                column = list(stacking  = 'normal',
                              label     = list(enabled = FALSE)),
                bar    = list(stacking  = 'normal',
                              label     = list(enabled = FALSE))
              ) %>%
              hc_title(
                text  = "Direct flow shortage",
                style = list(
                  fontSize = 20, fontWeight = "bold", color = "black")
                ) %>%
              # hc_colors(RColorBrewer::brewer.pal(n = length(df_list),  "Spectral")) %>%
              hc_colors(RColorBrewer::brewer.pal(n = length(df_list),  "Paired")) %>%
              # hc_colors(viridisLite::viridis(n = length(df_list), direction = 1)) %>%
              # hc_colors(viridisLite::cividis(n = length(df_list), direction = -1)) %>%
              hc_xAxis(
                categories = df_list[[1]][1],
                tickInterval  = 2,
                labels   = list(
                  y      = 35,
                  style  = list(fontSize = 16, color = "black", fontWeight = "bold"))
                # labels     = list(style = list(fontSize =  '1.1em')),
                ) %>%
              hc_yAxis_multiples(
                list(
                  title     = list(
                    text      =  "Direct shortage (AF)",
                    style     = list(fontSize = 14, color = "black", fontWeight = "bold")),
                    labels    = list(
                    style      = list(fontSize = 16, color = "black", fontWeight = "bold")),
                  top    = "0%",
                  height = "100%"),
                list(
                  title     = list(
                    text      =  "Direct shortage (% of demand)",
                    style     = list(fontSize = 14, color = "black", fontWeight = "bold")),
                  labels   = list(
                    style     = list(fontSize = 16, color = "black", fontWeight = "bold")),
                  top          = "0%",
                  height       = "100%",
                  min          = 0,
                  max          = 100,
                  tickInterval = 20,
                  opposite     = TRUE,
                  y            = 35)) %>%
              # hc_yAxis(title = list(
              #   text =  "Direct flow shortage (AF)",
              #   style = list(fontWeight = "bold",  fontSize = '1.2em')),
              #   labels = list(style = list(fontSize =  '1.1em'))) %>%
              hc_add_theme(custom_theme) %>%
              # hc_add_theme(hc_theme_elementary()) %>%
              hc_chart(plotBorderWidth = 0.5, plotBorderColor = '#b4b4b4', height = NULL)
  return(right_short_plot)
}

plot_right_demand <- function(df_list) {

  right_demand_plot <-
    highchart() %>%
          hc_plotOptions(
            # series = list(label = list(enabled = FALSE)),
            line   = list(
              marker   = list(enabled = FALSE, symbol = "circle"),
              label    = list(enabled = FALSE), lineWidth = 4),
            area   = list(
              stacking = 'normal',
              marker   = list(enabled = FALSE),
              label    = list(enabled = FALSE)),
            column = list(
              stacking = 'normal',
              label    = list(enabled = FALSE)),
            bar    = list(
              stacking = 'normal',
              label    = list(enabled = FALSE))
          ) %>%
          hc_title(
            text  = "Demand",
            style = list(
              fontSize = 20, fontWeight = "bold", color = "black")
                   ) %>%
          # hc_colors(RColorBrewer::brewer.pal(n = length(df_list),  "Spectral")) %>%
          hc_colors(RColorBrewer::brewer.pal(n = length(df_list),  "Paired")) %>%
          # hc_colors(rev(RColorBrewer::brewer.pal(n = length(df_list),  "Paired"))) %>%
          # hc_colors(viridisLite::viridis(n = length(df_list), direction = 1)) %>%
          # hc_colors(viridisLite::cividis(n = length(df_list), direction = -1)) %>%
          hc_xAxis(
            categories = df_list[[1]][1],
            tickInterval  = 2,
            labels   = list(
              y      = 35,
              style  = list(fontSize = 16, color = "black", fontWeight = "bold"))
            # labels     = list(style = list(fontSize =  '1.1em')),
          ) %>%
          hc_yAxis(
            title     = list(
              text      =  "Demand (AF)",
              style     = list(fontSize = 14, color = "black", fontWeight = "bold")),
            labels    = list(
              style      = list(fontSize = 16, color = "black", fontWeight = "bold"))
            ) %>%
          hc_add_theme(custom_theme) %>%
          # hc_add_theme(hc_theme_elementary()) %>%
          hc_chart(
            plotBorderWidth  = 0.5,
            plotBorderColor  = '#b4b4b4',
            height           = NULL)
  return(right_demand_plot)
}

# exceedance probability plotting function
plot_ep <- function(
  node_ep,
  district_ep,
  basin_ep,
  ep = "short_dir_pct_dem"
) {

  if(ep == "short_dir_pct_dem") {

    exceedance_prob_plot <-
      highchart() %>%
      hc_plotOptions(
        line  = list(marker = list(enabled = FALSE), lineWidth = 6)
      ) %>%
      hc_title(
        text  = "Exceedance Probability of Direct shortage (% of demand)",
        style = list(
          fontSize = 20, fontWeight = "bold", color = "black")
      ) %>%
      hc_yAxis(
        max    = 100,
        min    = 0,
        tickInterval  = 20,
        title  = list(
          text  = "Direct Shortage % of demand",
          style = list(fontSize = 16, color = "black", fontWeight = "bold")),
        labels = list(
          style = list(fontSize = 16, color = "black", fontWeight = "bold"))
      ) %>%
      hc_legend(
        itemStyle = list(
          fontSize = 16, color = "black", fontWeight = "bold")
      ) %>%
      hc_xAxis(
        max    = 100,
        min    = 0,
        tickInterval  = 20,
        title  = list(text = "Exceedance Probability (%)", style = list(fontSize = 16, color = "black", fontWeight = "bold")),
        labels = list(style = list(fontSize = 16, color = "black", fontWeight = "bold"))) %>%
      hc_add_series(
        data         = node_ep,
        hcaes(
          x = ep_pct_short_dir,
          y = short_dir_pct_dem),
        name         = "Node EP",
        type         = 'line',
        yAxis        = 0,
        fillOpacity  = 0.1,
        showInLegend = T) %>%
      hc_add_series(
        data         = district_ep,
        hcaes(
          x = ep_pct_short_dir,
          y = short_dir_pct_dem),
        name         = "District EP",
        type         = 'line',
        yAxis        = 0,
        fillOpacity  = 0.1,
        showInLegend = T) %>%
      hc_add_series(
        data         = basin_ep,
        hcaes(
          x = ep_pct_short_dir,
          y = short_dir_pct_dem),
        name         = "Basin EP",
        type         = 'line',
        yAxis        = 0,
        fillOpacity  = 0.1,
        showInLegend = T) %>%
      hc_add_theme(custom_theme) %>%
      # hc_add_theme(hc_theme_elementary()) %>%
      hc_colors(c("dodgerblue", "darkred", "darkgreen")) %>%
      hc_chart(
        plotBorderWidth = 0.5,
        plotBorderColor = '#b4b4b4',
        height          = NULL
      )

    return(exceedance_prob_plot)

  } else if (ep == "short_pct_dem") {
    exceedance_prob_plot <-
      highchart() %>%
      hc_plotOptions(
        line  = list(marker = list(enabled = FALSE), lineWidth = 6)
      ) %>%
      hc_title(
        text  = "Exceedance Probability of Total shortage as a % of demand",
        style = list(
          fontSize = 20, fontWeight = "bold", color = "black")
      ) %>%
      hc_yAxis(
        max    = 100,
        min    = 0,
        tickInterval  = 20,
        title  = list(
          text  = "Total Shortage % of demand",
          style = list(fontSize = 16, color = "black", fontWeight = "bold")),
        labels = list(
          style = list(fontSize = 16, color = "black", fontWeight = "bold"))
      ) %>%
      hc_legend(
        itemStyle = list(
          fontSize = 16, color = "black", fontWeight = "bold")
      ) %>%
      hc_xAxis(
        max    = 100,
        min    = 0,
        tickInterval  = 20,
        title  = list(text = "Exceedance Probability (%)", style = list(fontSize = 16, color = "black", fontWeight = "bold")),
        labels = list(style = list(fontSize = 16, color = "black", fontWeight = "bold"))) %>%
      hc_add_series(
        data         = node_ep,
        hcaes(
          x = ep_pct_short,
          y = short_pct_dem),
        name         = "Node EP",
        type         = 'line',
        yAxis        = 0,
        fillOpacity  = 0.1,
        showInLegend = T) %>%
      hc_add_series(
        data         = district_ep,
        hcaes(
          x = ep_pct_short,
          y = short_pct_dem),
        name         = "District EP",
        type         = 'line',
        yAxis        = 0,
        fillOpacity  = 0.1,
        showInLegend = T) %>%
      hc_add_series(
        data         = basin_ep,
        hcaes(
          x = ep_pct_short,
          y = short_pct_dem),
        name         = "Basin EP",
        type         = 'line',
        yAxis        = 0,
        fillOpacity  = 0.1,
        showInLegend = T) %>%
      hc_add_theme(custom_theme) %>%
      # hc_add_theme(hc_theme_elementary()) %>%
      hc_colors(c("dodgerblue", "darkred", "darkgreen")) %>%
      hc_chart(
        plotBorderWidth = 0.5,
        plotBorderColor = '#b4b4b4',
        height          = NULL
      )

    return(exceedance_prob_plot)
  }
}
plot_demand_rank <- function(node) {
  demand_rank_plot <-
    highchart() %>%
      hc_plotOptions(line = list(marker = list(enabled = FALSE), lineWidth = 7)) %>%
      hc_title(text = "Demand rank") %>%
      hc_add_series(
        data = node,
        type = 'line',
        name = unique(node$id),
        hcaes(
          x     = year,
          group = id,
          y     = demand_rank
        ),
        fillOpacity = 0.5
      ) %>%
      hc_colors(RColorBrewer::brewer.pal(n = length(unique(node$id)),  "Paired")) %>%
      hc_xAxis(
        categories = node$year,
        labels     = list(style = list(fontSize =  '1.1em'))) %>%
      hc_yAxis(
        title  = list(
          text   = "Demand rank",
          style  = list(fontWeight = "bold",  fontSize = '1.2em')),
        labels = list(style = list(fontSize =  '1.1em'))) %>%
      hc_add_theme(custom_theme) %>%
      # hc_add_theme(hc_theme_elementary()) %>%
      hc_chart(
        plotBorderWidth  = 0.5,
        plotBorderColor  = '#b4b4b4',
        height           = NULL)
  return(demand_rank_plot)

}
plot_climate_forecast <- function(
                                prediction_data,
                                historic_data,
                                future_data,
                                dep_label,
                                ind_label
                                ) {

  # prediction_data = pred_df
  # historic_data   = historic_sample
  # future_data     = future_sample
  # dep_label       = impact_label
  # ind_label       = indicator_label

  # Future density plot
  density_future <- future_data$y
  # density_future <- density(future_data[[2]])$y

  # Historic density plot
  density_hist   <- historic_data$y
  # density_hist <- density(historic_data[[2]])$y

  climate_forecasts_density_plot <-
    highchart() %>%
        hc_plotOptions(
          line    = list(
                      marker    = list(enabled = FALSE, symbol = "circle"),
                      lineWidth = 5
                      ),
          scatter = list(
                      marker    = list(symbol = "circle")
                      )
          ) %>%
        hc_title(
          text   = "Frequency Distribution",
          style   = list(fontSize = 20, fontWeight = "bold", color = "black")) %>%
        hc_yAxis_multiples(
          list(
            title    = list(
                        text  = "",
                        style = list(fontSize = 16, fontWeight = "bold", color = "black")
                        ),
            labels   = list(
                        style = list(fontSize = 16, color = "black", fontWeight = "bold")
                        ),
            min      = 0,
            max      = pmax(max(density_future), max(density_hist)),
            y        = 40,
            opposite = TRUE),
          list(
            title    = list(
                        text  = dep_label,
                        style = list(fontSize = 16, fontWeight = "bold", color = "black")
                        ),
            labels   = list(
                        style = list(fontSize = 16, color = "black", fontWeight = "bold")
                        ),
            min      = 0,
            max      = max(prediction_data$prediction),
            y        = 40)
          ) %>%
        hc_xAxis(
          title = list(
                    text  = ind_label,
                    style = list(fontSize = 16, fontWeight = "bold", color = "black")
                    ),
          labels = list(
                    style = list(fontSize = 16, color = "black", fontWeight = "bold")
                    )
          ) %>%
        hc_legend(
          itemStyle   = list(fontSize = 16, color = "black", fontWeight = "bold")
          ) %>%
        hc_add_series(
          data = historic_data,          # data        = density(historic_data[[2]]),
          hcaes(
            x = x,
            y = y
          ),
          type        = 'area',
          name        = paste0("Historic distribution"),
          yAxis       = 0,
          fillOpacity = 0.5) %>%
        hc_add_series(
          data = future_data,       # data        = density(future_data[[2]]),
          hcaes(
            x = x,
            y = y
          ),
          type        = 'area',
          name        = paste0("Projected distribution"),
          yAxis       = 0,
          fillOpacity = 0.4) %>%
        hc_add_series(
          data        = dplyr::arrange(prediction_data, independent_future),
          type        = 'line',
          name        = dep_label,
          hcaes(
            x = independent_future,
            y =  prediction
            ),
          yAxis       = 1,
          fillOpacity = 0.7) %>%
        hc_add_theme(custom_theme) %>%
        # hc_add_theme(hc_theme_elementary()) %>%
        hc_colors(c("#679890", "#98676F", "black")) %>% # "#5D6D7E"
        hc_chart(
          plotBorderWidth = 0.5,
          plotBorderColor = '#b4b4b4',
          height          = NULL
          )

  return(climate_forecasts_density_plot)
}

plot_future_prediction <- function(
                                predictors,
                                impacts,
                                clean_text,
                                dep_label,
                                ind_label,
                                number_vars = 2
                                ) {

  # predictors <- predictor_ts
  # impacts     <- impact_ts
  # clean_text <- name_data
  # dep_label <- impact_label
  # ind_label <- indicator_label
  # vars <- length(clean_text$var)

  if(number_vars == 2) {

      future_prediction_plot <-
            highchart() %>%
                hc_plotOptions(
                  column = list(stacking = 'normal'),
                  line   = list(marker = list(enabled = FALSE), lineWidth = 5)) %>%
                hc_title(
                  text   = "Predicted Water Shortages",
                  style   = list(fontSize = 20, fontWeight = "bold", color = "black")) %>%
                hc_yAxis(
                  title  = list(text = "Water volume (acre feet)"),
                  min    = 0) %>%
                hc_legend(itemStyle = list(fontSize = 16, color = "black", fontWeight = "bold")) %>%
                hc_yAxis_multiples(
                  list(
                    title = list(
                      text  = clean_text$clean_name[1],
                      style = list(fontSize = 16, fontWeight = "bold", color = "black")),
                  labels  = list(style = list(fontSize = 16, color = "black", fontWeight = "bold")),
                  top     = "0%",
                  height  = "33%"
                  ),
                  list(
                    title = list(
                      text   = clean_text$clean_name[2],
                      style  = list(fontSize = 16, fontWeight = "bold", color = "black")),
                    labels = list(
                       style = list(fontSize = 16, color = "black", fontWeight = "bold")),
                    top    = "33%",
                    height = "33%",
                    opposite = TRUE)
                  ,
                  list(title = list(
                    text   = dep_label,
                    style  = list(fontSize = 16, fontWeight = "bold", color = "black")),
                    labels = list(style = list(fontSize = 16, color = "black", fontWeight = "bold")),
                    top      = "66%",
                    height = "33%",
                    opposite = F)
                ) %>%
                hc_xAxis(
                  categories   = predictors$year,
                  tickInterval = 10,
                  title        = list(
                    text  = "Year",
                    style = list(fontSize = 16, color = "black", fontWeight = "bold")),
                  labels       = list(
                    style = list(fontSize = 16, color = "black", fontWeight = "bold")),
                  plotBands    = list(
                    list(
                      from  = 1970,
                      to    = 2020,
                      color = "rgba(0, 100, 0, 0.1)",
                      label = list(
                        text  = "Historical record",
                        style = list(fontSize = 16, color = "black", fontWeight = "bold" )))
                    )
                  ) %>%
                hc_add_series(
                  data        = predictors,
                  name        = clean_text$clean_name[1],
                  type        = 'line',
                  hcaes(x = year,  y = !!clean_text$var[1]),
                  # hcaes(x = year,  y = !!lm_run$predictors[1]),
                  yAxis       = 0,
                  fillOpacity = 0.1) %>%
                hc_add_series(
                  data        = predictors,
                  name        = clean_text$clean_name[2],
                  type        = 'line',
                  hcaes(x = year,  y = !!clean_text$var[2]),
                  # hcaes(x = year, y =  !!lm_run$predictors[2]),
                  yAxis       = 1,
                  fillOpacity = 0.1) %>%
                hc_add_series(
                  data        = dplyr::arrange(impacts, year),
                  type        = 'column',
                  name        = dep_label,
                  # hcaes(x = Independent, y = Dependent),
                  hcaes(x = year, y =  impact),
                  yAxis       = 2,
                  fillOpacity = 0.5) %>%
                hc_xAxis(categories = predictors$year) %>%
                hc_add_theme(custom_theme) %>%
                # hc_add_theme(hc_theme_elementary()) %>%
                hc_colors(c("darkblue",  "darkred", "black")) %>%
                hc_chart(plotBorderWidth = 0.5, plotBorderColor = '#b4b4b4', height = NULL)
      return(future_prediction_plot)
  } else {
        future_prediction_plot <-
          highchart() %>%
            hc_plotOptions(
              column = list(stacking = 'normal'),
              line   = list(marker = list(enabled = FALSE), lineWidth = 5)) %>%
            hc_title(
              text   = "Predicted Water Shortages",
              style   = list(fontSize = 20, fontWeight = "bold", color = "black")) %>%
            hc_yAxis(
              title  = list(text = "Water volume (acre feet)"),
              min    = 0) %>%
            hc_legend(itemStyle = list(fontSize = 16, color = "black", fontWeight = "bold")) %>%
            hc_yAxis_multiples(
              list(
                title = list(
                  # text   = name_df$clean_name[1],
                  text  = clean_text$clean_name[1],
                  style = list(fontSize = 16, fontWeight = "bold", color = "black")),
                labels  = list(style = list(fontSize = 16, color = "black", fontWeight = "bold")),
                top     = "0%",
                height  = "50%"
              ),
              list(title = list(
                text   = dep_label,
                style  = list(fontSize = 16, fontWeight = "bold", color = "black")),
                labels = list(style = list(fontSize = 16, color = "black", fontWeight = "bold")),
                top      = "50%",
                height = "50%",
                opposite = F)
            ) %>%
            hc_xAxis(
              categories   = predictors$year,
              tickInterval = 10,
              title        = list(
                text  = "Year",
                style = list(fontSize = 16, color = "black", fontWeight = "bold")),
              labels       = list(
                style = list(fontSize = 16, color = "black", fontWeight = "bold")),
              plotBands    = list(
                list(
                  from  = 1970,
                  to    = 2020,
                  color = "rgba(0, 100, 0, 0.1)",
                  label = list(
                    text  = "Historical record",
                    style = list(fontSize = 16, color = "black", fontWeight = "bold" )))
              )
            ) %>%
            hc_add_series(
              data        = predictors,
              name        = clean_text$clean_name[1],
              type        = 'line',
              hcaes(x = year,  y = !!clean_text$var[1]),
              # hcaes(x = year,  y = !!lm_run$predictors[1]),
              yAxis       = 0,
              fillOpacity = 0.1) %>%
            hc_add_series(
              data        = dplyr::arrange(impacts, year),
              type        = 'column',
              name        = dep_label,
              # hcaes(x = Independent, y = Dependent),
              hcaes(x = year, y =  impact),
              yAxis       = 1,
              fillOpacity = 0.5) %>%
            hc_xAxis(categories = predictors$year) %>%
            hc_add_theme(custom_theme) %>%
            # hc_add_theme(hc_theme_elementary()) %>%
            hc_colors(c("darkblue", "black")) %>%
            hc_chart(plotBorderWidth = 0.5, plotBorderColor = '#b4b4b4', height = NULL)
        return(future_prediction_plot)
  }
}

# Makes table of Node IDs
make_node_table <- function(node_data) {

  # node_data <- node_table_data %>%
  #   filter(node_id == "7200938")

  node_table <-
    reactable::reactable(
      node_data,
      style    = list(fontFamily = "Work Sans, sans-serif", fontSize = "12px", fontWeight = 600),
      columns  = list(
        name       = colDef(
                name  = "Structure Name",
                align = "center"),
        node_id    = colDef(
                name  = "WDID",
                align = "center",
                cell  = function(value, index) {
                                  node_url <- sprintf("https://dwr.state.co.us/Tools/Structures/%s", node_data[index, "node_id"])
                                  node_id  <- paste(node_data[index, "node_id"])
                                  tagList(
                                    tags$a(class = "node_id", href = node_url, target = "_blank", node_id)
                                  )
                                }
          ),
        id         = colDef(
                name  = "ID",
                align = "center"),
        admin      = colDef(
                name  = "Priority Admin No.",
                align = "center"),
        admin_rank = colDef(
                name  = "Admin No. rank",
                align = "center"),
        date       = colDef(
                name  = "Appropriation Date",
                align = "center")
        ),
    highlight = TRUE,
    outlined  = TRUE,
    bordered  = T,
    theme     = reactableTheme(
      borderColor = "#black",
      cellStyle   = list(
        display         = "flex",
        flexDirection   = "column",
        justifyContent  = "center"
        ),
      headerStyle = list(
        backgroundColor = "hsl(207, 16%, 80%)"
        )
      )
    )
  # %>% add_subtitle("Structure Information",align = "center",  font_size = 16, margin = 3)

  return(node_table)
}

# Make table to display MLR results
make_mlr_table <- function(table_data) {

  rsq_colors <- data.frame("R squared" = c(0, 1))

  # Clean reactable table
  mlr_table <- reactable(
    table_data,
    style = list(fontFamily = "Work Sans, sans-serif", fontSize = "14px", fontWeight = 600),
    defaultColDef = colDef(
      align = "center",
      style = pos_neg_colors("red", "green", bold = TRUE)),
    columns = list(
      "R2" = colDef(
        style = color_scales(rsq_colors, span = TRUE, colors = c("#FFFFcc", "#4c9900"),
                             opacity = .7, bold_text = T,
                             text_color = "black",
                             brighten_text_color = "black"),
      ),
      "Intercept" = colDef(
        style = pos_neg_colors("black", "black", bold = TRUE)
      )),
    # style = pos_neg_colors("red", "green", bold = TRUE))
    # ),
    highlight = TRUE,
    # outlined = T,
    # bordered = T,
    # compact = T,
    theme = reactableTheme(
      borderColor = "black",
      # cellStyle = list(display = "flex", flexDirection = "column", justifyContent = "center"),
      headerStyle = list(
        backgroundColor = "hsl(207, 16%, 80%)"),
    )
  )
  return(mlr_table)
}


zoom_to_district = function(map, df, district){
          shp = filter(df, comid == district) # Build a buffered bounding box to center the map on:
          bounds = shp %>% # make bounding box
                st_bbox() %>% # Make spatial
                st_as_sfc() %>% # Buffer to .1 degree
                st_buffer(.1) %>% # make new bounding box
                st_bbox() %>% # extract coordinates as vector
                as.vector() # Clear all current shapes
            clearShapes(map) %>% # Add the county shape making the outline color red and the fill an opaque white
            addPolygons(
                data = shp,
                color = "red",
                fillColor  = "grey",
                fillOpacity = .3) %>%
            flyToBounds(bounds[1], bounds[2], bounds[3], bounds[4]) # Fly the leaflet map to the buffered boundary
}

# Make water supply/demand/augmented supply ggplot, choice of area or bar
ws_plot <- function(data, type = c("area", "bar"), xbreaks = 16) {
  if(type == "area") {
    ggplot() +
      geom_area(
        data = data,
        aes(x = Year, y =value, fill = name),
        col = "darkgrey",
        size = 0.1,
        position = "stack"
      ) +
      geom_line(
        data = data,
        aes(x = Year, y = short_dir),
        col = "black",
        size = 1
      ) +
      labs(
        y = "Water volume (M/gal)",
        x = "Year",
        title = "Water supply and demand",
        fill  = " "
      ) +
      scale_y_continuous(breaks = scales::pretty_breaks(n = 6))+
      scale_x_continuous(breaks = scales::pretty_breaks(n = xbreaks))+
      hrbrthemes::theme_ipsum() +
      theme(
        axis.title.x  = element_text(size = 14,  face = "bold"),
        axis.title.y  = element_text(size = 14, face = "bold"),
        plot.title    = element_text(size = 16, face = "bold", hjust = 0.5)
      )
  } else {
    ggplot() +
      geom_col(
        data = data,
        aes(x = Year, y =value, fill = name),
        color = "black",
        size = 0.1,
        position = "stack"
        # position = position_dodge2(width = 0)
        # stat = "identity"
      ) +
      geom_line(
        data = data,
        aes(x = Year, y = short_dir),
        col = "black",
        size = 1
      ) +
      labs(
        y = "Water volume (M/gal)",
        x = "Year",
        title = "Water supply and demand",
        fill  = " "
      ) +
      scale_y_continuous(breaks = scales::pretty_breaks(n = 6))+
      scale_x_continuous(breaks = scales::pretty_breaks(n = xbreaks))+
      hrbrthemes::theme_ipsum() +
      theme(
        axis.title.x  = element_text(size = 14,  face = "bold"),
        axis.title.y  = element_text(size = 14, face = "bold"),
        plot.title    = element_text(size = 16, face = "bold", hjust = 0.5)
      )
  }
}

normalize <- function(x) {
  return ((x - min(x)) / (max(x) - min(x)))
}

# Robust scalar normalization
robust_scalar<- function(x){
  (x- median(x)) /(quantile(x,probs = .75)-quantile(x,probs = .25))
}

# Min-Max Normalization
norm_minmax <- function(x){
  (x- min(x)) /(max(x)-min(x))
}

# Mean Normalization
mean_norm_minmax <- function(x){
  (x- mean(x)) /(max(x)-min(x))
}

# Load function data_utils.R file
# source('data_utils.R')
# source("/app/R/data_utils.R", local = FALSE)
```

```{r context="server"}
# useShinyalert(rmd = TRUE)

# model_data <- readRDS("model_data_all.rds")
# model_data      <- readRDS("statemod_climate_year.rds")
model_data      <- aws.s3::s3readRDS(
  object = "statemod_climate_year.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# fitted MLR data
# mlr_fit         <- readRDS("mlr_fit.rds")
mlr_fit      <- aws.s3::s3readRDS(
  # object = "statemod_climate_year.rds",
  object = "mlr_fit.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# district MLR predictors
# mlr_predictors  <- readRDS("mlr_predictors.rds")
mlr_predictors      <- aws.s3::s3readRDS(
  object = "mlr_predictors.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# Tidied MLR results by district
# mlr_metrics     <- readRDS("mlr_metrics.rds")
mlr_metrics      <- aws.s3::s3readRDS(
  object = "mlr_metrics.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# fitted Univariete regression data
# lm_fit          <- readRDS("lm_fit.rds")
lm_fit      <- aws.s3::s3readRDS(
  object = "lm_fit.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# Tidied Univariete regression results by district
# lm_metrics      <- readRDS("lm_metrics.rds")
lm_metrics      <- aws.s3::s3readRDS(
  object = "lm_metrics.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# data for water supply/demand/shortages timeseries
# ws_ts           <- readRDS("water_timeseries.rds")
ws_ts      <- aws.s3::s3readRDS(
  object = "water_timeseries.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# fitted MLR future data
# mlr_future_fit        <- readRDS("mlr_future_fit.rds")
mlr_future_fit      <- aws.s3::s3readRDS(
  object = "mlr_future_fit.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# Tidied MLR future results by district
# mlr_future_metrics    <- readRDS("mlr_future_metrics.rds")
mlr_future_metrics      <- aws.s3::s3readRDS(
  object = "mlr_future_metrics.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# district MLR future predictors
# mlr_future_predictors <- readRDS("mlr_future_predictors.rds")
mlr_future_predictors      <- aws.s3::s3readRDS(
  object = "mlr_future_predictors.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# lm_future_fit         <- readRDS("lm_future_fit.rds") %>%
#   mutate(district = as.numeric(district))
lm_future_fit      <- aws.s3::s3readRDS(
  object = "lm_future_fit.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
) %>%
  dplyr::mutate(district = as.numeric(district))

# annual climate data from 1970 - 2099
# future_climate_ts     <- readRDS("future_climate_timeseries.rds") %>%
  # mutate(district = as.numeric(district))
future_climate_ts      <- aws.s3::s3readRDS(
  object = "future_climate_timeseries.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
) %>%
  dplyr::mutate(district = as.numeric(district))

# district shapefile path
# shp_path        <- "water_districts.geojson"

 # load shapefiles as spatial polygon object
# shp <- sf::read_sf(paste0(shp_path), quiet = TRUE)
shp <- sf::read_sf("https://cpo-shiny-data.s3.us-west-1.amazonaws.com/water_districts.gpkg")

# list of basin names
# basin_lst   <- readRDS("match_basin_district.rds")
basin_lst      <- aws.s3::s3readRDS(
  object = "match_basin_district.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# # Water rights node points 
# node_pts    <- readRDS("shortage_by_right_pts.rds")
node_pts      <- aws.s3::s3readRDS(
  object = "shortage_by_right_pts.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# Exceedance probabilities data
# node_ep     <- readRDS("node_ep.rds")
node_ep      <- aws.s3::s3readRDS(
  object = "node_ep.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# district_ep <- readRDS("district_ep.rds")
district_ep      <- aws.s3::s3readRDS(
  object = "district_ep.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# basin_ep    <- readRDS("basin_ep.rds")
basin_ep      <- aws.s3::s3readRDS(
  object = "basin_ep.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# annual shortages by right
# ditch_data  <- readRDS("shortages_by_right_rank_year.rds")
ditch_data      <- aws.s3::s3readRDS(
  object = "shortages_by_right_rank_year.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# cleaned node information for table
# node_table_data <- readRDS("node_id_table.rds")
node_table_data      <- aws.s3::s3readRDS(
  object = "node_id_table.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# density of future climate data
# samples_future     <- readRDS("climate_future_density.rds") %>%
  # mutate(district = as.numeric(district))
samples_future      <- aws.s3::s3readRDS(
  object = "climate_future_density.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
) %>%
  dplyr::mutate(district = as.numeric(district))


# density of historic climate data
# samples_historic   <- readRDS("climate_historic_density.rds") %>%
  # mutate(district = as.numeric(district))
samples_historic      <- aws.s3::s3readRDS(
  object = "climate_historic_density.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
) %>%
  dplyr::mutate(district = as.numeric(district))

# Clean dataframe of names for plot labels
# clean_names <- readRDS("clean_variable_names.rds")
clean_names      <- aws.s3::s3readRDS(
  object = "clean_variable_names.rds",
  bucket = "cpo-shiny-data",
  region = "us-west-1"
)

# # admin number to appropriation date look up table
# admin_dates <- readRDS("admin_dates.rds") %>%
#   mutate(date = as.character(date))
# samples_future     <- readRDS("climate_future_samples.rds")
# samples_historic   <- readRDS("climate_historic_samples.rds")

# node_pts <- readRDS("node_pts3.rds")
# ditch_data3 <- readRDS("ditch_data3.rds")
# ditch_names <- readRDS("ditch_names2.rds")

# climate_models <- readRDS("maca_data.rds")
# climate_samples <- readRDS("maca_tidy_samples.rds")

# climate_models     <- readRDS("climate_future_year.rds") %>% 
#   mutate(year = as.numeric(as.character(year))) %>% 
#   filter(year <= 2099)


# present_climate    <- readRDS("climate_present_year.rds")

# dataset_lst <- list("MACA", "BCCA", "LOCA")
# short_year <- readRDS("model_data_year_v3.rds")


# clean indicator names
indicator_lst <- list(
  "Precipitation (mm)"                 = "prcp",
  "District SWE maximum (mm)"          = "swe",
  "Basin SWE maximum (mm)"             = "swe_max",
  "Average temperature (C)"            = "tavg",
  "Maximum temperature (C)"            = "tmax",
  "Minimum temperature (C)"            = "tmin",
  "Actual Evapotranspiration (mm)"     = "aet",
  "Potential Evapotranspiration (mm)"  = "pet",
  "Soil moisture (mm)"                 = "soilm",
  "PDSI"                               = "pdsi",
  "EDDI 1 month"                       = "eddi1",
  "EDDI 3 month"                       = "eddi3",
  "EDDI 6 month"                       = "eddi6", 
  "EDDI 9 month"                       = "eddi9", 
  "EDDI 12 month"                      = "eddi12",
  "SPI 1 month"                        = "spi1",
  "SPI 3 month"                        = "spi3",
  "SPI 6 month"                        = "spi6",
  "SPI 9 month"                        = "spi9",
  "SPI 12 month"                       = "spi12"
  )

# clean impacts names
impacts_lst <- list(
  "Total shortage (AF)"                 = "short",
  "Total shortage (% of demand)"        = "short_pct_dem",
  "Direct shortage (AF)"                = "short_dir",
  "Direct shortage (% of demand)"       = "short_dir_pct_dem",
  "Demand (AF)"                         = "demand",
  "Supply (AF)"                         = "supply",
  "Direct supply (AF)"                  = "supply_dir"
  # "Natural flows (AF)"                  = "af_total"
)

# clean climate model names
clim_model_indicator_lst <- list(
  "Precipitation (mm)"                 = "prcp",
  "Average temperature (C)"            = "tavg",
  "Maximum temperature (C)"            = "tmax",
  "Minimum temperature (C)"            = "tmin",
  "Potential Evapotranspiration (mm)"  = "pet",
  "PDSI"                               = "pdsi",
  "SPI 1 month"                        = "spi1",
  "SPI 3 month"                        = "spi3",
  "SPI 6 month"                        = "spi6",
  "SPI 9 month"                        = "spi9",
  "SPI 12 month"                       = "spi12"
  )

# Initialize Maps 

# Multiple linear regression tab
output$districtMapMLR       <- renderLeaflet({ mlr_map(shp = shp) })

# univariate regression tab
output$districtMapLM        <- renderLeaflet({ basemap(shp = shp) })

# water rights tab
# output$districtMap          <- renderLeaflet({ mlr_map(shp = shp) })
output$districtMap          <- renderLeaflet({ ep_map(shp = shp) })
# output$nodeMap              <- renderLeaflet({ basemap(shp = shp) })

# climate tab
output$districtMapFuture    <- renderLeaflet({ basemap(shp = shp) })

```




Multiple Linear Regression
=====================================
Inputs {.sidebar}
----------------------------------------------------
***
### **A multiple linear regression approach to determine the collection of climate variables that best predict water shortages in each district.**

***

<br>

#### **How to:**

***

##### **1.** Click on a water district on the map to the right.

##### **2.** Hover over each panel for an explanation of what each shows.

***

###
```{r}
actionButton(
  "modelRunHelpButton",
  # label = "Help",
  # class = "btn-primary btn-lg",
  icon("question")
  )

observeEvent(input$modelRunHelpButton, {
  shinyalert(title = "What is multiple linear regression?",
             closeOnClickOutside = TRUE,
             showCancelButton = TRUE,
             text = "A multiple linear regression (MLR) is a statistical technique that uses several explanatory variables to predict the outcome of a response variable. The goal of multiple linear regression is to model the linear relationship between the explanatory (independent) variables and response (dependent) variables.\n
             \nTo calculate climate sensitivity, we multiplied the variance of each district’s shortages by the R-squared of the district’s MLR model. By doing so, we can compare across districts to understand why one district may be more or less sensitive to drought conditions than others.")
})
```

```{r context="server"}
mlr_district <- reactive({
   input$districtMapMLR_shape_click$id
})
```


Column {data-width=250}
-----------------------------------------------------------------------
###
```{r}
valueBoxOutput("districtBoxMLR")
```

### Water districts
```{r}


leafletOutput("districtMapMLR")
bsPopover("districtMapMLR", title = "Water districts", content = "The colors on the represents the impact drought conditions have on water shortages within each district. This climate sensitivity metric was generated by multiplying the R2 from the MLR model by the annual variance in water shortages. This calculation attempts to display the strength of the relationship between drought indicators and year to year shortages in each district",
          placement = "right", options = list(container = "body"))
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```


```{r context="server"}

# render district value box at start
output$districtBoxMLR <- renderValueBox(
                    valueBox(
                      value = "District: ",
                      color = "success"
                  )
                )

# Clicking on map 1 outputs Value boxes on both pages + catchment polygons + Dat table + success panel
# observeEvent(input$districtMapMLR_click, {
observeEvent(input$districtMapMLR_shape_click, {
    print(mlr_district())

   # if(!is.null(input$districtMapMLR_click)) {
      click <- input$districtMapMLR_click %>%
        data.frame() %>%
        dplyr::select(lat,lng)
      print(click)

      pt <- sf::st_as_sf(
        click,
        coords = c("lng", "lat"),
        crs = 4326
        )

          # District number value box
          output$districtBoxMLR <- renderValueBox(
            valueBox(
              value = paste0("District: ", mlr_district()),
              color = "success"
              )
            )
          # pal <- colorNumeric("YlOrRd", domain = shp$variance_rsq, n = 21)
          pal <- colorNumeric(viridisLite::magma(n = 30, direction = -1), domain = shp$var_sensitivity_norm, reverse = F, n = 30)
          # pal <- colorNumeric("Spectral", domain = shp$var_sensitivity_norm, reverse = T, n = 30)

          bb = shp %>%
              st_bbox() %>%
              st_as_sfc() %>%
              st_transform(4326) %>%
              st_as_sf()
          # Map 2 fly to bounds
          bounds <- st_bbox(bb) %>%
              st_as_sfc() %>%
              st_buffer(0.009) %>%
              st_bbox() %>%
              as.vector()

          leafletProxy("districtMapMLR") %>%
              clearMarkers() %>%
              clearShapes() %>%
              addMarkers(data = pt) %>%
              addPolygons(
                    data = shp,
                    color = "black",
                    opacity = 1,
                    fillOpacity = 0.7,
                    fillColor = ~pal(var_sensitivity_norm),
                    weight = 2,
                    label          = ~paste0("District: ", DISTRICT),
                    layerId = ~DISTRICT,
                    labelOptions = labelOptions(
                      noHide = F,
                      # direction = 'center',
                      # textOnly = F)
                      style = list(
                        "color" = "black",
                        "font-weight" = "1000")
                  )
                )
       })
```


<!-- ```{r context="server"} -->
<!-- # render district value box at start -->
<!-- output$districtBoxMLR <- renderValueBox( -->
<!--                     valueBox( -->
<!--                       value = "District", -->
<!--                       color = "success" -->
<!--                   ) -->
<!--                 ) -->
<!-- # tooltip(refId = "districtMapMLR", text = "District map - Information on climate sensitivity color") -->

<!-- # Clicking on map 1 outputs Value boxes on both pages + catchment polygons + Dat table + success panel -->
<!-- observeEvent(input$districtMapMLR_click, { -->
<!--    # if(!is.null(input$districtMapMLR_click)) { -->

<!--       click <- input$districtMapMLR_click %>% -->
<!--             data.frame() %>% -->
<!--             dplyr::select(lat,lng) -->
<!--       print(click) -->

<!--       pt <- sf::st_as_sf( -->
<!--           click, -->
<!--           coords = c("lng", "lat"), -->
<!--           crs = 4326 -->
<!--         ) -->
<!--           # District number value box -->
<!--           output$districtBoxMLR <- renderValueBox( -->
<!--             valueBox( -->
<!--               value = paste0("District ", mlr_district()), -->
<!--               color = "success" -->
<!--               ) -->
<!--             ) -->
<!--           bb = shp %>% -->
<!--               st_bbox() %>% -->
<!--               st_as_sfc() %>% -->
<!--               st_transform(4326) %>% -->
<!--               st_as_sf() -->
<!--           # Map 2 fly to bounds -->
<!--           bounds <- st_bbox(bb) %>% -->
<!--               st_as_sfc() %>% -->
<!--               st_buffer(0.009) %>% -->
<!--               st_bbox() %>% -->
<!--               as.vector() -->

<!--           pal <- colorNumeric(viridisLite::magma(n = 30, direction = -1), domain = shp$var_sensitivity_norm, reverse = F, n = 30) -->
<!--           # pal <- colorNumeric("Spectral", domain = shp$var_sensitivity_norm, reverse = T, n = 30) -->
<!--           # pal <- colorNumeric("YlOrRd", domain = shp$variance_rsq, n = 21) -->

<!--           leafletProxy("districtMapMLR") %>% -->
<!--               clearMarkers() %>% -->
<!--               clearShapes() %>% -->
<!--               addMarkers(data = pt) %>% -->
<!--               addPolygons( -->
<!--                       data = shp, -->
<!--                       color = "black", -->
<!--                       opacity = 1, -->
<!--                       fillOpacity = 0.7, -->
<!--                       fillColor = ~pal(var_sensitivity_norm), -->
<!--                       weight = 2, -->
<!--                       label          = ~paste0("District: ", DISTRICT), -->
<!--                       layerId = ~DISTRICT, -->
<!--                       labelOptions = labelOptions( -->
<!--                         noHide = F, -->
<!--                         # direction = 'center', -->
<!--                         # textOnly = F) -->
<!--                         style = list( -->
<!--                           "color" = "black", -->
<!--                           "font-weight" = "1000") -->
<!--                     ) -->
<!--                   ) -->
<!-- }) -->
<!-- ``` -->

###
```{r}

highcharter::highchartOutput("MLRfittedPointPlot")
# bs_embed_tooltip("MLRfittedPointPlot", title = "The model performance is evaluated by plotting the observed water shortages against predicted water shortages. The closer the points are to the 1:1 line, the better the fit of the model to the observed data.", options = list(container = "body"))
bsPopover("MLRfittedPointPlot", title ="Model Performance", content = "The model performance is evaluated by plotting the observed water shortages against predicted water shortages. The closer the points are to the 1:1 line, the better the fit of the model to the observed data.",
                    "right", options = list(container = "body"))
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```

```{r context = "server"}
# observeEvent(input$districtMapMLR_click, {
observeEvent(input$districtMapMLR_shape_click, {
  district_fit <- mlr_fit %>%
    filter(district == mlr_district())
    # filter(district == 23)

  district_predictors <- mlr_predictors %>%
    filter(district == mlr_district())
    # filter(district == 23)

  # one-to-one plot
  mod_performance_plot <- plot_fitted(
                                    fitted_data = district_fit
                                    )
  #  ---- render highcharter plot ----
  output$MLRfittedPointPlot <- renderHighchart({
    mod_performance_plot
    })
})
```

Column {data-width=550}
-------------------------------------
###
```{r}
# "Direct flow supply (dark blue bars) is the water that comes directly from stream flow.
# Augmented supply (light blue bars) is the water from other sources (e.g. reservoirs). Some districts have access to a lot of augmented supply, others do not.The gap between the demand line and the two supply bars is the total shortage that a water district faced.",
# plotly::plotlyOutput("wsTimeseries")

highcharter::highchartOutput("wsTimeseries")
# tippy_this(elementId = "wsTimeseries" ,tooltip = "Direct flow supply (dark blue bars) is the water that comes directly from stream flow.
#  Augmented supply (light blue bars) is the water from other sources (e.g. reservoirs).", placement = "right")
bsPopover("wsTimeseries", title = "Water supply timeseries", content = "Direct flow supply (dark blue bars) is the water that comes directly from stream flow.
Augmented supply (light blue bars) is the water from other sources (e.g. reservoirs).", placement = "top", options = list(container = "body"))
#
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))

```

```{r context = "server"}
# observeEvent(input$districtMapMLR_click, {
observeEvent(input$districtMapMLR_shape_click, {
                district_ws <- ws_ts %>%
                  filter(district == mlr_district())
                    # filter(district == 23)

                # ---- HC Dem/sup bar + shortage line ----
                water_ts_plot <- plot_water_ts(district_ws)

                #  ---- render plotly plot ----
                output$wsTimeseries <- renderHighchart({
                      water_ts_plot
                })
  })
```

###
```{r}
highcharter::highchartOutput("predictorTimeseries")
bsPopover("predictorTimeseries", title = "Best climate predictors of shortages in district", content = "Using a step-wise function, the MLR chose a handful of climate predictors that best predicted shortages for a particular district. These are the observed timeseries for the climate predictors that produced the best model.

Compare the timeseries of the climate predictors to the timeseries of shortages above to see how they relate.",
  placement =  "left", options = list(container = "body"))
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```

```{r context = "server"}
# observeEvent(input$districtMapMLR_click, {
observeEvent(input$districtMapMLR_shape_click, {

    # ---- District MLR predictors ----
    district_predictors <- 
      mlr_predictors   %>%
      filter(district == mlr_district()) %>%
      # filter(district == 68) %>%
      slice(n = 1:2)

    predictors_data <- 
      model_data %>%
      dplyr::select(district, year, district_predictors$variable) %>%
      filter(district == mlr_district()) %>%
      # filter(district == 68)  %>%
      dplyr::select(-district)


    if(length(district_predictors$variable) > 1) {
       print("multiple predictors")

       # get clean names for plot
       plot_labels <- clean_names %>%
         filter(var %in% district_predictors$variable)

       # ---- Predictors highchart ----
       predictors_ts_plot <-  plot_mlr_predictors(
         predictors  = predictors_data,
         names       = plot_labels,
         number_vars = 2
         )

       #  ---- render predictors HC plot ----
       output$predictorTimeseries <- renderHighchart({
         predictors_ts_plot
         })
       } else {
         print("single predictor")

         # get clean names for plot
         plot_labels <- clean_names %>%
           filter(var %in% district_predictors$variable)

         # ---- Predictors highchart ----
         predictors_ts_plot <-  plot_mlr_predictors(
               predictors  = predictors_data,
               names       = plot_labels,
               number_vars = 1
               )
         #  ---- render predictors HC plot ----
         output$predictorTimeseries <- renderHighchart({
           predictors_ts_plot
         })
         }
    })
```




Univariate Linear Regression
=====================================
Inputs {.sidebar}
----------------------------------------------------

***
### **Explore a univariate approach to understand how a certain climate variable relates to water shortages in each district​**

***

<br>

#### **How to:**

***

##### **1.** Click on a water district on the map to the right.

##### **2.** Choose the type of response variable you wish to view.

##### **3.** Choose the type of climate indicator you wish to view

##### **4.** Click Run Model button

##### **5.** Hover over each panel for an explanation of what each shows.

<br>

#### **Model inputs:**

***

##### **Dependent variables**
```{r}
# use_bs_tooltip()

selectInput(
  "depVarInput",
  label = NULL,
  # selected = "short_norm",
    # choices = as.list(outcome_lst$outcome_variable)
  selected = "Total shortage",
  choices = impacts_lst
)
# bs_embed_tooltip(title = "TEXT")
# bsTooltip("depVarInput", "INSERT TEXT HERE",
#                     "right", options = list(container = "body"))
# tags$style(HTML("
#                 .tooltip > .tooltip-inner {
#                 width: 400px;
#                 color: black;
#                 background-color: white;
#                 }
#                 "))
```

##### **Drought indicators**
```{r}
selectInput(
  "climVarInput",
  label = NULL,
  # selected = "prcp",
  # choices = as.list(indepent_lst$independent_variable)
  selected = "Precipitation",
  choices = indicator_lst
  # choices = as.list(indepent_lst2$independent_variable)
  )
# bsTooltip("climVarInput", "INSERT TEXT HERE",
#                     "right", options = list(container = "body"))
# tags$style(HTML("
#                 .tooltip > .tooltip-inner {
#                 width: 400px;
#                 color: black;
#                 background-color: white;
#                 }
#                 "))
```

***

#####
```{r}
actionButton(
  "submitButton",
  label = "Run model",
  class = "btn-success",
  icon("play")
  )

```

#####
```{r}
# actionButton(
#   "climVarHelpButton",
#   # label = "Help",
#   # class = "btn-primary btn-lg",
#   icon("question")
#   )
#
# observeEvent(input$climVarHelpButton, {
#   shinyalert(title = "Hey",
#              showCancelButton = TRUE,
#              closeOnClickOutside = TRUE,
#              text = "Info on Drought indicators")
# })
```

***

```{r context = "server"}
# Dependent variable input reactive
depVar <- reactive({
  input$depVarInput
})

# climate variable input reactive
climVar <- reactive({
  input$climVarInput
})

# clicked district
lm_district <- reactive({
   input$districtMapLM_shape_click$id
})


# basin <- reactive({
#   b <- basin_lst %>%
#       filter(DISTRICT == input$districtMapMLR_shape_click$id)
#     # filter(DISTRICT == dist())
#     # filter(DISTRICT == "6")
#   b <- b$BASIN
# })
```

Column {data-width=250}
-----------------------------------------------------------------------

###
```{r}
valueBoxOutput("districtBoxLM")
```

### Water districts
```{r}
leafletOutput("districtMapLM")
bsPopover("districtMapLM", title = "Water districts", content = "The river basins in Colorado are divided into water districts. Climate and response variables are averaged by district area.", placement =  "right",
          options = list(container = "body")
          )
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```


```{r context="server"}
# render district value box at start
# output$districtBoxLM <- renderValueBox(
#                     valueBox(
#                       value = "District",
#                       color = "success"
#                   )
#                 )
# 
# # # Clicking on map 1 outputs Value boxes on both pages + catchment polygons + Dat table + success panel
# observeEvent(input$districtMapLM_click, {
#        # if(!is.null(input$districtMapLM_click)) {
#           click <- input$districtMapLM_click %>%
#             data.frame() %>%
#             dplyr::select(lat,lng)
#           print(click)
# 
#           pt <- sf::st_as_sf(
#             click,
#             coords = c("lng", "lat"),
#             crs = 4326
#             )
# 
#           # District number value box
#           output$districtBoxLM <- renderValueBox(
#             valueBox(
#               value = paste0("District ", lm_district()),
#               color = "success"
#               )
#             )
# 
#           pal <- colorNumeric(viridisLite::magma(n = 30, direction = -1), domain = shp$var_sensitivity_norm, reverse = F, n = 30)
#           # pal <- colorNumeric("Spectral", domain = shp$var_sensitivity_norm, reverse = T, n = 30)
#           # pal <- colorNumeric("YlOrRd", domain = shp$variance_rsq, n = 21)
# 
#           bb = shp %>%
#               st_bbox() %>%
#               st_as_sfc() %>%
#               st_transform(4326) %>%
#               st_as_sf()
#           # Map 2 fly to bounds
#           bounds <- st_bbox(bb) %>%
#               st_as_sfc() %>%
#               st_buffer(0.009) %>%
#               st_bbox() %>%
#               as.vector()
#         # pal_fact <- colorFactor(c("darkorange", "lightgreen"), domain = shp$BASIN)
# 
#           leafletProxy("districtMapLM") %>%
#               clearMarkers() %>%
#               clearShapes() %>%
#               addMarkers(data = pt) %>%
#               addPolygons(
#                         data = shp,
#                         color = "black",
#                         opacity = 1,
#                         fillOpacity = 0.7,
#                         # fillColor = ~pal_fact(BASIN),
#                         fillColor = 'white',
#                         weight = 2.5,
#                         label          = ~paste0("District: ", DISTRICT),
#                         labelOptions = labelOptions(
#                           noHide = F,
#                           # direction = 'center',
#                           # textOnly = F)
#                           style = list(
#                             "color" = "black",
#                             "font-weight" = "1000")
#                           )
#                       ) %>%
#                   addScaleBar("bottomleft") %>%
#                   leafem::addMouseCoordinates() %>%
#                   flyToBounds(bounds[1], bounds[2], bounds[3], bounds[4])
# })
```


```{r context="server"}
# render district value box at start
output$districtBoxLM <- renderValueBox(
                    valueBox(
                      value = "District: ",
                      color = "success"
                  )
                )

# Clicking on map 1 outputs Value boxes on both pages + catchment polygons + Dat table + success panel
# observeEvent(input$districtMapLM_click, {
observeEvent(input$districtMapLM_shape_click, { 
   # if(!is.null(input$districtMapLM_click)) {
      click <- input$districtMapLM_click %>%
        data.frame() %>%
        dplyr::select(lat,lng)
      print(click)

      pt <- sf::st_as_sf(
        click,
        coords = c("lng", "lat"),
        crs = 4326
        )
          # District number value box
          output$districtBoxLM <- renderValueBox(
            valueBox(
              value = paste0("District: ", lm_district()),
              color = "success"
              )
          )

          bb = shp %>%
              st_bbox() %>%
              st_as_sfc() %>%
              st_transform(4326) %>%
              st_as_sf()
          # Map 2 fly to bounds
          bounds <- st_bbox(bb) %>%
              st_as_sfc() %>%
              st_buffer(0.009) %>%
              st_bbox() %>%
              as.vector()

          # pal <- colorNumeric("YlOrRd", domain = shp$variance_rsq, n = 21)
          # pal_fact <- colorFactor(c("darkorange", "lightgreen"), domain = shp$BASIN)
          pal <- colorNumeric(viridisLite::magma(n = 30, direction = -1), domain = shp$var_sensitivity_norm, reverse = F, n = 30)
          # pal <- colorNumeric("Spectral", domain = shp$var_sensitivity_norm, reverse = T, n = 30)

          leafletProxy("districtMapLM") %>%
              clearMarkers() %>%
              clearShapes() %>%
              addMarkers(data = pt) %>%
              addPolygons(
                        data           = shp,
                        color          = "black",
                        opacity        = 1,
                        fillOpacity    = 0.6,
                        # fillColor = ~pal_fact(BASIN),
                        fillColor      = 'white',
                        weight         = 2.5,
                        label          = ~paste0("District: ", DISTRICT),
                        layerId        = ~DISTRICT,
                        labelOptions   = labelOptions(
                                            noHide = F,
                                            style  = list(
                                              "color" = "black",
                                              "font-weight" = "1000"
                                              ))
                        ) %>%
                addScaleBar("bottomleft") %>%
                # leafem::addMouseCoordinates() %>%
                flyToBounds(bounds[1], bounds[2], bounds[3], bounds[4])
})
```

### Model summary {data-height=75}
```{r}
formattable::formattableOutput("modelSummary")
bsPopover("modelSummary", title = "Model Summary", content = "This is a summary table containing the coefficients and R Squared for the linear model.",placement = "left", options = list(container = "body"))

tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
# he regression coefficient value (value in red) signifies the strength of the linear relationship and is the m in the regression equation “y = mx +b”. The sign of this value tells us whether there is a positive or negative correlation between the climate predictor and the response variable. A positive coefficient indicates that as the value of climate variable increases, the mean of the response variable also tends to increase. A negative coefficient suggests that as the climate variable increases, the dependent variable tends to decrease.
#
# The R Squared value is a statistical measure of how close the data are to the fitted regression line. The higher the R squared value, the better the climate variable is at predicting the response variable.

```

```{r context = "server"}
# modelSummaryData <- eventReactive(input$submitButton, {
#   if(is.null(lm_district())) {
#     
#     return(NULL)
#     
#     } else {
#       district_metrics <- lm_metrics %>%
#         filter(district == lm_district(), ind_var == climVar(), dep_var == depVar()) %>%
#         # filter(district == 7, ind_var == "tavg", dep_var == "short_pct_dem") %>%
#         dplyr::select(-district, -ind_var, -dep_var)
#       format_tbl <-
#         formattable(district_metrics,
#                     align = c("l",rep("r", NCOL(district_metrics) - 1 )),
#                     list(
#                       `Term` = formatter("span", style = ~ style(color = "black", font.weight = "bold")),
#                       `Coefficient` = improvement_formatter,
#                       area(col = 3:4) ~ color_tile("#EAECEE", "#EAECEE"))
#                     )
#       format_tbl
#       
#       }
# })

# output$modelSummary <- renderFormattable({
                  # modelSummaryData()
                  # })
observeEvent(input$submitButton, { 
   if(is.null(lm_district())) {
    
    return(NULL)
    
    } else {
      district_metrics <- lm_metrics %>%
        filter(district == lm_district(), ind_var == climVar(), dep_var == depVar()) %>%
        # filter(district == 7, ind_var == "tavg", dep_var == "short_pct_dem") %>%
        dplyr::select(-district, -ind_var, -dep_var)
      format_tbl <-
        formattable(district_metrics,
                    align = c("l",rep("r", NCOL(district_metrics) - 1 )),
                    list(
                      `Term` = formatter("span", style = ~ style(color = "black", font.weight = "bold")),
                      `Coefficient` = improvement_formatter,
                      area(col = 3:4) ~ color_tile("#EAECEE", "#EAECEE"))
                    )
      output$modelSummary <- renderFormattable({
                  format_tbl
                  })
      }
})

```

Column {data-width=550}
-------------------------------------
###
```{r}
# plotly::plotlyOutput("wsTimeseries")
highcharter::highchartOutput("lmPlot")
bsPopover("lmPlot", title = "Regression Line and Density Plot", content = "This plot shows the relationship between the climate predictor you’ve chosen (x-axis) and the response variable (y-axis). The points are the historical observations from individual water rights in the district.The fitted black line is the regression line that consists of the predicted value for the response variable (y) for each possible value for the climate variable (x).\nThe blue area curve is a density plot of the chosen climate predictor data which shows the distribution of the data over the period of record.\n",
placement = "right", options = list(container = "body"))

tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
# verbatimTextOutput("lmPlot")
# The fitted black line is the regression line that consists of the predicted value for the response variable (y) for each possible value for the climate variable (x). The blue area curve is a density plot of the chosen climate predictor data which shows the distribution of the data over the period of record.
```

```{r context = "server"}
# lmModelData <- eventReactive(input$submitButton, {
#                     district_lm <- lm_fit %>%
#                       filter(district == lm_district(), ind_var == climVar(), dep_var == depVar()) %>%
#                       # filter(district == 1, ind_var == "prcp", dep_var == "short_dir_pct_dem") %>%
#                       dplyr::select(-district, -ind_var, -dep_var)
# 
#                     # get clean names for plot
#                     indicator_label <- clean_names %>%
#                        filter(var == climVar())
#                         # filter(var %in% district_lm$ind_var)
#                     indicator_label <- indicator_label$clean_name
# 
#                      # get clean names for plot
#                     impact_label    <- clean_names %>%
#                         filter(var == depVar())
#                         # filter(var %in% district_lm$dep_var)
#                     impact_label <- impact_label$clean_name
# 
#                     # Regression line and climate density plot
#                     lm_density_plot  <- plot_lm_density(
#                                                      df        = district_lm,
#                                                      dep_label = impact_label,
#                                                      ind_label = indicator_label
#                                                      )
# 
#                     lm_density_plot
#           })
# 
# output$lmPlot <- renderHighchart({
#           lmModelData()
#                 })

observeEvent(input$submitButton, { 
   if(is.null(lm_district())) {
    
    return(NULL)
    
    } else {
      district_lm <- lm_fit %>%
        filter(district == lm_district(), ind_var == climVar(), dep_var == depVar()) %>%
        # filter(district == 1, ind_var == "prcp", dep_var == "short_dir_pct_dem") %>%
        dplyr::select(-district, -ind_var, -dep_var)
      
      # get clean names for plot
      indicator_label <- clean_names %>%
        filter(var == climVar())
      # filter(var %in% district_lm$ind_var)
      
      indicator_label <- indicator_label$clean_name
      
      # get clean names for plot
      impact_label    <- clean_names %>%
        filter(var == depVar())
      # filter(var %in% district_lm$dep_var)
      
      impact_label <- impact_label$clean_name
      
      # Regression line and climate density plot
      lm_density_plot  <- plot_lm_density(
                                      df        = district_lm,
                                      dep_label = impact_label,
                                      ind_label = indicator_label
                                      )
                    
      output$lmPlot <- renderHighchart({
          lm_density_plot
                })
      }
})

```

Water Rights
=======================================
Inputs {.sidebar}
----------------------------------------------------
***
### **Explore individual water rights by diversion structure to see how demands and direct flow shortages are modeled over time**

***

<br>

#### **How to:**

***

##### **1.** Click on a water district on the map to the right.

##### **2.** Water nodes for the selected district will be displayed on the map.

##### **3.** Click on a water node to view average annual water demands and water shortages for each administrative right within that water node


***

Column {data-width=550}
-----------------------------------------------------------------------

```{r context="server"}
# reactive district number
node_district <- reactive({
   input$districtMap_shape_click$id
})

# reactive basin name
basin <- reactive({
  b <- basin_lst %>%
      filter(DISTRICT == input$districtMap_shape_click$id)
    # filter(DISTRICT == node_district())
    # filter(DISTRICT == "6")
  b <- b$BASIN
})

# reactive Node ID
node <- reactive({
      input$districtMap_marker_click$id
})

```

###
```{r}
valueBoxOutput("districtBoxNode")
```

### Water districts
```{r}
leafletOutput("districtMap")
bsPopover("districtMap", title = "Water districts", content = "Click a district to view water nodes within that district. The districts are colored by the mean annual direct flow shortages as a percentage of total demand within the district. The size of the water node represents average annual demand for that node, and the color indicates whether it is an agricultural (red) or municipal (blue) node.",
                    "right", options = list(container = "body"))
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```

###
```{r}
valueBoxOutput("nodeIDBox")
```

```{r context="server"}
# render district value box at start
output$districtBoxNode <- renderValueBox(
                    valueBox(
                      value = "District: ",
                      color = "success"
                  )
                )

# render district value box at start
output$nodeIDBox <- renderValueBox(
                    valueBox(
                      value = "Node ID: ",
                      color = "success"
                  )
                )

# Clicking on map 1 outputs Value boxes on both pages + catchment polygons + Dat table + success panel
# observeEvent(input$districtMap_click, {
observeEvent(input$districtMap_shape_click, {
   if(is.null(node_district())) {
     return(NULL)
   } else {
   # if(!is.null(input$districtMap_click)) {
   # if(!is.null(input$districtMap_shape_click)) {
          click <- input$districtMap_click %>%
              data.frame() %>%
              dplyr::select(lat,lng)

              print(click)

          pt <- sf::st_as_sf(
              click,
              coords = c("lng", "lat"),
              crs = 4326
              )

          # District number value box
          output$districtBoxNode <- renderValueBox(
            valueBox(
              value = paste0("District: ", node_district()),
              # value = paste0("District ", district_id$district),
              color = "success"
              )
            )

          # pal <- colorNumeric("YlOrRd", domain = shp$variance_rsq, n = 21)
          # pal <- colorNumeric(viridisLite::magma(n = 30, direction = -1), domain = shp$var_sensitivity_norm, reverse = F, n = 30)
            # pal <- colorNumeric("Spectral", domain = shp$var_sensitivity_norm, reverse = T, n = 30)
          
            # values 0 - 100%
            vect = seq(0, 100, 10)
          
            # binned colors of mean annual direct flow shortage as % of demand
            binpal <- colorBin(
                              "Spectral",
                              domain  = vect,
                              n       = 4,
                              reverse = T,
                              pretty  = T
                              )
          bb <- shp %>%
                # filter(DISTRICT == 7) %>%
                filter(DISTRICT == node_district()) %>%
                st_bbox() %>%
                st_as_sfc() %>%
                st_transform(4326) %>%
                st_as_sf()
  
          # Fly to bounds on Node map
          bounds <- st_bbox(bb) %>%
                st_as_sfc() %>%
                # st_buffer(0.009) %>%
                st_bbox() %>%
                as.vector()
  
          node_marker <- node_pts %>%
              filter(district == node_district())
                # filter(district == 7)
          
          leafletProxy("districtMap") %>%
              clearMarkers() %>%
              clearShapes() %>%
              addMarkers(data = pt) %>%
              addPolygons(
                  data         = filter(shp, DISTRICT != node_district()),
                  # data         = filter(shp, DISTRICT != 43),
                  # data         = shp,
                  color        = "black",
                  opacity      = 1,
                  fillOpacity  = 0.7,
                  fillColor    = ~binpal(mean_short_dir),
                  # fillColor    = ~pal(var_sensitivity_norm),
                  weight       = 2,
                  label        = ~paste0("District: ", DISTRICT),
                  layerId      = ~DISTRICT,
                  labelOptions = labelOptions(
                    noHide = F,
                    style = list(
                      "color"       = "black",
                      "font-weight" = "1000")
                  )
                ) %>%
             addPolygons(
                  data         = filter(shp, DISTRICT == node_district()),
                  # data         = filter(shp, DISTRICT == 43),
                  color        = "black",
                  opacity      = 1,
                  fillOpacity  = 0.7,
                  fillColor    = ~binpal(mean_short_dir),
                  # fillColor    = ~pal(var_sensitivity_norm),
                  weight       = 6,
                  label        = ~paste0("District: ", DISTRICT),
                  layerId      = ~DISTRICT,
                  labelOptions = labelOptions(
                    noHide = F,
                    style = list(
                      "color"       = "black",
                      "font-weight" = "1000")
                  )
                ) %>%
             addCircleMarkers(
                  data        = node_marker,
                  # radius      = ~((2 + size)*5),
                  radius      = ~(size_sq),
                  # radius      = ~(5 + size*6),
                  color       = "black",
                  fillColor   = node_marker$color,
                  fillOpacity = 0.7,
                  opacity     = 1,
                  weight      = 3,
                  stroke      = TRUE,
                  layerId     = ~node_id,
                  group       = "Nodes",
                  label       = ~paste0("Node ID: ", node_id),
                  labelOptions = labelOptions(
                    noHide = F,
                    style = list(
                      "color" = "black",
                      "font-weight" = "1000")
                  )) %>%
             flyToBounds(bounds[1], bounds[2], bounds[3], bounds[4])
          
          print(paste0(node_district()))
          print(paste0(basin()))
          print(paste0(node()))
}
})
  # observeEvent(input$districtMap_marker_click, {
  #     # if(!is.null(input$districtMap_marker_click)) {
  #     # node <<- input$nodeMap_marker_click$id
  #     # ---- Node timeseries ----
  #     # filter data to node
  #     # ditch <- ditch_data %>%
  #     #   filter(node_id == node) %>%
  #     #   group_by(year, admin) %>%
  #     #   summarize(across(c(19:24), sum)) %>%
  #     #   ungroup()
  # 
  #     # split node by admin
  #     node_split_short <- ditch_data %>%
  #       filter(node_id == node()) %>%
  #       # filter(node_id == "0700699") %>%
  #       # filter(node_id == "0200809") %>%
  #       mutate(admin = as.numeric(admin)) %>% # mutate(admin = round(as.numeric(admin), 0)) %>%
  #       group_by(id) %>%
  #       mutate(x = year, y = round(short_dir, 1)) %>%
  #       dplyr::select(x, y, admin, id) %>%
  #       group_split() %>%
  #       as.list() %>%
  #       rev()
  # 
  #     # initialize highchart
  #     right_short_plot <- plot_right_short(df_list = node_split_short)
  # 
  #     # for loop to generate highcharter series for each admin number
  #     for (i in 1:length(node_split_short)) {
  #       right_short_plot <- right_short_plot %>%
  #           hc_add_series(
  #             node_split_short[[i]],
  #             name        = paste0(node_split_short[[i]][1,4]),   # name is ID
  #             type        = "column",
  #             # type        = "area",
  #             fillOpacity = 1
  #             )
  #       }
  # 
  #     output$adminShortagePlot <- renderHighchart({
  #         right_short_plot
  #       })
  #     # }
  # })
              # addPolygons(
              #       data         = shp,
              #       color        = "black",
              #       opacity      = 1,
              #       fillOpacity  = 0.7,
              #       fillColor    = ~pal(var_sensitivity_norm),
              #       weight       = 2,
              #       label        = ~paste0("District: ", DISTRICT),
              #       layerId      = ~DISTRICT,
              #       labelOptions = labelOptions(
              #         noHide = F,
              #         # direction = 'center',
              #         # textOnly = F)
              #         style = list(
              #           "color"       = "black",
              #           "font-weight" = "1000")
              #         )
              #       ) %>% 
              # addCircleMarkers(
              #             data        = node_marker,
              #             radius      = ~(size_sq),
              #             # radius      = ~(size_root),
              #             # radius      = ~(5 + size*6),
              #             color       = "black",
              #             fillColor   = node_marker$color,
              #             fillOpacity = 0.7,
              #             opacity     = 1,
              #             weight      = 3,
              #             stroke      = TRUE,
              #             layerId     = ~node_id,
              #             label       = ~paste0("Node ID: ", node_id),
              #             labelOptions = labelOptions(
              #               noHide = F,
              #               style = list(
              #                 "color" = "black",
              #                 "font-weight" = "1000")
              #               )) %>%
              # flyToBounds(bounds[1], bounds[2], bounds[3], bounds[4])

          # bb <- shp %>%
          #     # filter(DISTRICT == 7) %>%
          #     filter(DISTRICT == node_district()) %>%
          #     st_bbox() %>%
          #     st_as_sfc() %>%
          #     st_transform(4326) %>%
          #     st_as_sf()
          # 
          # # Fly to bounds on Node map
          # bounds <- st_bbox(bb) %>%
          #     st_as_sfc() %>%
          #     # st_buffer(0.009) %>%
          #     st_bbox() %>%
          #     as.vector()
          # 
          # node_marker <- node_pts %>%
          #   filter(district == node_district())
          #     # filter(district == "72")
          # 
          # leafletProxy("nodeMap") %>%
          #       clearMarkers() %>%
          #       clearShapes() %>%
          #       addPolygons(
          #             data = filter(shp, DISTRICT == node_district()),
          #            # data = filter(shp, DISTRICT == 72),
          #             fillColor = 'white',
          #             fillOpacity = 0.7,
          #             col = "black",
          #             opacity = 1,
          #             weight = 2.5,
          #             label          = ~paste0("District: ", DISTRICT),
          #             layerId        = ~DISTRICT,
          #             labelOptions = labelOptions(
          #                 noHide = F,
          #                 # direction = 'center',
          #                 # textOnly = F)
          #                 style = list(
          #                   "color" = "black",
          #                   "font-weight" = "1000")
          #                 )
          #             ) %>%
          #        addCircleMarkers(
          #               data        = node_marker,
          #               radius      = ~(size_sq),
          #               # radius      = ~(size_root),
          #               # radius      = ~(5 + size*6),
          #               color       = "black",
          #               fillColor   = node_marker$color,
          #               fillOpacity = 0.7,
          #               opacity     = 1,
          #               weight      = 3,
          #               stroke      = TRUE,
          #               layerId     = ~node_id,
          #               label       = ~paste0("Node ID: ", node_id),
          #               labelOptions = labelOptions(
          #                 noHide = F,
          #                 style = list(
          #                   "color" = "black",
          #                   "font-weight" = "1000")
          #                 )) %>%
          #        flyToBounds(bounds[1], bounds[2], bounds[3], bounds[4])
   
  # })

# Clicking on map 1 outputs Value boxes on both pages + catchment polygons + Dat table + success panel
# observeEvent(input$districtMap_marker_click, {
#    # if(!is.null(input$districtMap_click)) {
# 
#           click <- input$districtMap_click %>%
#               data.frame() %>%
#               dplyr::select(lat,lng)
# 
#               print(click)
# 
#           pt <- sf::st_as_sf(
#               click,
#               coords = c("lng", "lat"),
#               crs = 4326
#               )
# 
#           # District number value box
#           output$districtBoxNode <- renderValueBox(
#             valueBox(
#               value = paste0("District ", node_district()),
#               # value = paste0("District ", district_id$district),
#               color = "success"
#               )
#             )
# 
#           # pal <- colorNumeric("YlOrRd", domain = shp$variance_rsq, n = 21)
#           pal <- colorNumeric(viridisLite::magma(n = 30, direction = -1), domain = shp$var_sensitivity_norm, reverse = F, n = 30)
#             # pal <- colorNumeric("Spectral", domain = shp$var_sensitivity_norm, reverse = T, n = 30)
#  
#   
#           node_marker <- node_pts %>%
#                   filter(district == node_district())
#                   # filter(district == 7)
#           
#           bb <- node_marker %>%
#                   filter(node_id == node()) %>%
#                   # filter(node_id == "0700699") %>%
#                   st_buffer(2000) %>% 
#                   st_bbox() %>%
#                   st_as_sfc() %>%
#                   st_transform(4326) %>%
#                   st_as_sf()
#   
#           # Fly to bounds on Node map
#           bounds <- bb %>% 
#                   st_bbox() %>%
#                   st_as_sfc() %>% 
#                   st_bbox() %>%
#                   as.vector()
#           
#           leafletProxy("districtMap") %>%
#                clearMarkers() %>%
#                clearShapes() %>%
#                addMarkers(data = pt) %>%
#                flyToBounds(bounds[1], bounds[2], bounds[3], bounds[4])
#           
#           print(paste0(node_district()))
#           print(paste0(basin()))
#           print(paste0(node()))
#       
#   })

```

###
```{r}
highcharter::highchartOutput("exceedanceProbPlot")
bsPopover("adminShortagePlot", title = "Exceedance Probability Curve", content = "Exceedance probability curves are used to estimate the probability that a certain value will be exceeded in the future. This EP Curve represents the probability of direct flow shortages occuring in any given year, according to historical records at the basin, district, and node level.", "bottom", options = list(container = "body"))
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
# leafletOutput("nodeMap")
# bsPopover("nodeMap",title = "Water nodes", content = "After clicking a district on the left, this map will load the water nodes for that district. The size of the water node represents average annual demand for that node.",
#                     "right", options = list(container = "body"))
# tags$style(HTML("
#                 .tooltip > .tooltip-inner {
#                 width: 400px;
#                 color: black;
#                 background-color: white;
#                 }
#                 "))
```

```{r context="server"}
# observeEvent(input$nodeMap_marker_click, {
observeEvent(input$districtMap_marker_click, {
  if(is.null(node())) {
    
    return(NULL)
    
    } else {
      # District number value box
      output$nodeIDBox <- renderValueBox(
                  valueBox(
                    value = paste0("Node ID: ", node()),
                    color = "success"
                    )
                  )
      }
  })
```

```{r context="server"}
 # observeEvent(input$nodeMap_marker_click, {
observeEvent(input$districtMap_marker_click, {
  if(is.null(node())) {
    
    return(NULL)
    
    } else {
      
      node_prob <- node_ep %>%
        filter(node_id == node())
        # filter(node_id == "3800545")

      district_prob <- district_ep %>%
        filter(district == node_district())
        # filter(district == 38)

      basin_prob <- basin_ep %>%
        filter(basin == basin(), district == node_district())
        # filter(basin == "colorado", district == 38)
      
      ep_plot    <- plot_ep(
                     node_ep     = node_prob,
                     district_ep = district_prob,
                     basin_ep    = basin_prob,
                     ep          = "short_dir_pct_dem"
                     )
      
      # Output exceedance probability plot
      output$exceedanceProbPlot <- renderHighchart({
        ep_plot
        })
      
    print(paste0(node_district()))
    print(paste0(basin()))
    print(paste0(node()))
  }
})
```

Column
-----------------------------------------------
### 
```{r}
highcharter::highchartOutput("adminShortagePlot")
bsPopover("adminShortagePlot", title = "Total annual water shortages per admin", content = "The stacked bars represent the annual demand for each water right and the height of the bar represents total annual demand for the entire water node. The black line indicates the annual direct flow shortages as a percentage of demand for the entire node and is associated with the right side Y axis.", "bottom", options = list(container = "body"))
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```

```{r context="server"}
# observeEvent(input$nodeMap_marker_click, {
observeEvent(input$districtMap_marker_click, {
  if(is.null(node())) {
    
    return(NULL)
    
    } else {
      # split node by admin
      node_split_short <- ditch_data %>%
        filter(node_id == node()) %>%
        # filter(node_id == "0700699") %>%
        # filter(node_id == "7200938") %>%
        mutate(admin = as.numeric(admin)) %>% # mutate(admin = round(as.numeric(admin), 0)) %>%
        group_by(id) %>%
        mutate(
          x = year,
          y = round(short_dir, 1)
          ) %>%
        dplyr::select(x, y, admin, id)
      
      # node names for plotting
      node_names <- rev(unique(node_split_short$id))
  
      node_split_short <- node_split_short %>%
        group_split() %>%
        as.list() %>%
        rev()


    # initialize highchart
    right_short_plot <- plot_right_short(df_list = node_split_short)

    # for loop to generate highcharter series for each admin number
    for (i in 1:length(node_split_short)) {
      right_short_plot <- right_short_plot %>%
          hc_add_series(
            node_split_short[[i]],
            name        = node_names[i],   # name is ID
            # name        = paste0(node_split_short[[i]][1,4]),   # name is ID
            type        = "column",
            # type        = "area",
            fillOpacity = 1
            )
      }

    shortages_pct_dem <- ditch_data %>%
      filter(node_id == node()) %>%
      # filter(node_id == "7200938") %>%
      group_by(id) %>%
      mutate(
        year      = year,
        demand    = round(demand, 1),
        short_dir = round(short_dir, 1)
             ) %>%
      ungroup() %>%
      dplyr::select(year, demand, short_dir, id) %>%
      group_by(year) %>%
      summarize(
        short_dir_pct_dem = 100*(sum(short_dir)/sum(demand))
      ) %>%
      rename(
        x = year,
        y = short_dir_pct_dem
      )

    right_short_plot <- right_short_plot %>%
      hc_add_series(
            shortages_pct_dem,
            name        = "Direct shortage (% of demand)",   # name is ID
            # name        = paste0(node_split_short[[i]][1,4]),   # name is ID
            type        = "line",
            color       = "black",
            fillOpacity = 1,
            yAxis       = 1,
            hcaes(
              x = x,
              y = y
              )
            )
    
    # Output Node shortage plot
    output$adminShortagePlot <- renderHighchart({
        right_short_plot
      })
    }
})

```

###
```{r}
highcharter::highchartOutput("adminDemandPlot")
bsPopover("adminDemandPlot", title = "Total annual water demands per admin",  content = "The stacked bars represent the annual demand for each water right and the height of the bar represents total annual demand for the entire water node.",
                    "top", options = list(container = "body"))
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```

```{r context="server"}
# observeEvent(input$nodeMap_marker_click, {
observeEvent(input$districtMap_marker_click, {
  if(is.null(node())) {
    
    return(NULL)
    
    } else {
      
    # if(!is.null(input$districtMap_marker_click)) {
    node_split_demand <- ditch_data %>%
      filter(node_id == node()) %>%
      # filter(node_id == "7200938") %>%
      mutate(admin = as.numeric(admin)) %>%
      group_by(id) %>%
      mutate(x = year, y = round(demand, 1)) %>%
      dplyr::select(x, y, admin, id)

    node_names <- rev(unique(node_split_demand$id))

    node_split_demand <- node_split_demand %>%
      group_split() %>%
      as.list() %>%
      rev()

    # initialize highchart
    right_demand_plot <- plot_right_demand(
      df_list = node_split_demand
      )

    # for loop to generate highcharter series for each admin number
    for (i in 1:length(node_split_demand)) {
      right_demand_plot <- right_demand_plot %>%
        hc_add_series(
          node_split_demand[[i]],
          name        = node_names[i],
          # name        = paste0(node_split_demand[[i]][1,4]),
          type        = "column",
          # type        = "area",
          fillOpacity = 0.7)
      }

    # output node demand plot
    output$adminDemandPlot <- renderHighchart({
       right_demand_plot
      })
    }
})

```

###
```{r}
# ### Structure information {data-height=200}
reactable::reactableOutput("nodeTable")
bsPopover("nodeTable", title = "Water node structures",  content = "The structures included in each model node is listed in this table. The WDID is a unique identification number for each water right, and is linked to Colorado’s DWR dashboard with detailed information on the structure and its status. The priority admin number is a unique number that relates each node to its appropriation date. The lower the priority number, the more senior the water right. The appropriation date is the date at which the water right was legally recognized by Colorado’s water court. The earlier the date, the earlier in line a user falls. If there is not enough water in the river for everybody, the more senior water users (with a earlier date) receive water first.",
                    "left", options = list(container = "body"))
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```

```{r context = "server"}
# observeEvent(input$nodeMap_marker_click, {
observeEvent(input$districtMap_marker_click, {
    if(is.null(node())) {
    
    return(NULL)
    
    } else {
      
      
      node_table <- node_table_data %>%
        filter(node_id == node())
        # filter(node_id == "2302911")
      
      # output summary table
      output$nodeTable <- reactable::renderReactable({
          make_node_table(
            node_data = node_table
            )
          })
      }
  })
```


Climate Change Impacts
=====================================
Inputs {.sidebar}
----------------------------------------------------
***
### **Use climate model data to understand how a changing climate can impact water shortages in the future**

***

<br>

#### **How to:**

***

##### **1.** Click on a water district on the map to the right.

##### **2.** Choose the type of response variable you wish to view.

##### **3.** Click Run Model button

##### **4.** To see how the distribution of a climate variable will shift in the future, select a climate variable in the drop down.

##### **5.** Hover over each panel for an explanation of what each shows.

***

<br>

#####  **Model outcome**
```{r}
selectInput(
  "depClimChangeInput",
  label = NULL,
  # selected = "short_norm",
    # choices = as.list(outcome_lst$outcome_variable)
  # selected = "Total shortage",
  selected = "short",
  choices = impacts_lst
)
# bsTooltip("depClimChangeInput", "INSERT TEXT HERE",
#                     "right", options = list(container = "body"))
# tags$style(HTML("
#                 .tooltip > .tooltip-inner {
#                 width: 400px;
#                 color: black;
#                 background-color: white;
#                 }
#                 "))
```

####
```{r}
actionButton(
  "submitButton2",
  label = "Get MLR predictions",
  class = "btn-success",
  icon("play")
  )

```

<br>

##### **Density plot climate variables**
```{r}
selectInput(
  "climChangeVarInput",
  label    = NULL,
  selected = "prcp",
  choices  = clim_model_indicator_lst
  # choices = as.list(indepent_lst2$independent_variable)
  )

# bsTooltip("climChangeVarInput", "INSERT TEXT HERE",
#                     "right", options = list(container = "body"))
# tags$style(HTML("
#                 .tooltip > .tooltip-inner {
#                 width: 400px;
#                 color: black;
#                 background-color: white;
#                 }
#                 "))

# actionButton(
#   "climVarHelpButton",
#   # label = "Help",
#   # class = "btn-primary btn-lg",
#   icon("question")
#   )
#
# observeEvent(input$climVarHelpButton, {
#   shinyalert(title = "Hey",
#              showCancelButton = TRUE,
#              closeOnClickOutside = TRUE,
#              text = "Info on Drought indicators")
# })
# actionButton(
#   "modelRunHelpButton",
#   # label = "Help",
#   # class = "btn-primary btn-lg",
#   icon("question")
#   )
# 
# observeEvent(input$modelRunHelpButton, {
#   shinyalert(title = "Hey",
#              closeOnClickOutside = TRUE,
#              showCancelButton = TRUE,
#              text = "Press this button to run the model")
# })
```

```{r context = "server"}
# reactive district number
future_district <- reactive({
   input$districtMapFuture_shape_click$id
})

# Dependent variable input reactive
futureDepVar <- reactive({
  input$depClimChangeInput
})

# climate variable input reactive
futureClimVar <- reactive({
  input$climChangeVarInput
})
```

Column {data-width=250}
-----------------------------------------------------------------------

###
```{r}
valueBoxOutput("districtBoxFuture")
```

### Water districts
```{r}
leafletOutput("districtMapFuture")
bsPopover("districtMapFuture", title = "Water districts", content = "The river basins in Colorado are divided into water districts. Climate and response variables are averaged by district area.", placement =  "right",
          options = list(container = "body")
          )
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
```


```{r context="server"}
# render district value box at start
output$districtBoxFuture <- renderValueBox(
                    valueBox(
                      value = "District: ",
                      color = "success"
                  )
                )

# Clicking on map 1 outputs Value boxes on both pages + catchment polygons + Dat table + success panel
observeEvent(input$districtMapFuture_click, {
   # if(!is.null(input$districtMapFuture_click)) {
         click <- input$districtMapFuture_click %>%
              data.frame() %>%
              dplyr::select(lat,lng)

              print(click)

          pt <- sf::st_as_sf(
              click,
              coords = c("lng", "lat"),
              crs = 4326
              )

          # District number value box
          output$districtBoxFuture <- renderValueBox(
            valueBox(
              value = paste0("District: ", future_district()),
              # value = paste0("District ", district_id$district),
              color = "success"
              )
            )

          # pal <- colorNumeric("YlOrRd", domain = shp$variance_rsq, n = 21)

          bb = shp %>%
              st_bbox() %>%
              st_as_sfc() %>%
              st_transform(4326) %>%
              st_as_sf()

          # Map 2 fly to bounds
          bounds <- st_bbox(bb) %>%
              st_as_sfc() %>%
              st_buffer(0.009) %>%
              st_bbox() %>%
              as.vector()

          # pal <- colorNumeric(viridisLite::magma(n = 30, direction = -1), domain = shp$var_sensitivity_norm, reverse = F, n = 30)

          # pal_fact <- colorFactor(c("darkorange", "lightgreen"), domain = shp$BASIN)

          leafletProxy("districtMapFuture") %>%
              clearMarkers() %>%
              clearShapes() %>%
              addMarkers(data = pt) %>%
              addPolygons(
                        data         = shp,
                        color        = "black",
                        opacity      = 1,
                        # fillColor = ~pal_fact(BASIN),
                        fillColor    = 'white',
                        fillOpacity  = 0.6,
                        weight       = 2.5,
                        label          = ~paste0("District: ", DISTRICT),
                        layerId        = ~DISTRICT,
                        labelOptions = labelOptions(
                          noHide = F,
                          style = list(
                            "color" = "black",
                            "font-weight" = "1000")
                          )
                      ) %>%
                  addScaleBar("bottomleft") %>%
                  leafem::addMouseCoordinates() %>%
                  flyToBounds(bounds[1], bounds[2], bounds[3], bounds[4])
              # addPolygons(
              #       data = shp,
              #       color = "black",
              #       fillOpacity = 0.5,
              #       fillColor = ~pal(variance_rsq),
              #       weight = 2,
              #       label = ~DISTRICT,
              #       labelOptions = labelOptions(
              #         noHide = F,
              #         # direction = 'center',
              #         # textOnly = F)
              #         style = list(
              #           "color" = "black",
              #           "font-weight" = "1000")
              #     )

})
```

###
```{r}
highcharter::highchartOutput("predictionPlot")
bsPopover("predictionPlot", title = "Density plots", content = "This is a density plot showing the frequency of historical and projected climate predictors. Climate models centered around the year 2050 project a shift in the mean and standard deviation of the climate variable. The extent of the shift and change in spread depends on the climate variable and the district.", placement = "right", options = list(container = "body"))
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))
# verbatimTextOutput("tripleEvent")
# verbatimTextOutput("indepText")
# verbatimTextOutput("depText")
```

```{r context = "server"}
triple_event <- reactive({
  # if (is.null(input$districtMapFuture_click) | is.null(input$climChangeVarInput) | is.null(input$depClimChangeInput))
  #     return(NULL)
  req(input$districtMapFuture_click)
  req(input$climChangeVarInput)
  req(input$depClimChangeInput)
    paste(input$districtMapFuture_click ,  input$climChangeVarInput, input$depClimChangeInput)
})
#
# # output$tripleEvent <- renderPrint({
# #   triple_event()
# # })
# #
# # output$indepText <- renderPrint({
# #   futureClimVar()
# # })
# #
# # output$depText <- renderPrint({
# #   futureDepVar()
# # })
#
#
# predictImpactsData <- eventReactive(triple_event(), {
#   # c(input$districtMapFuture_shape_click, input$climChangeVarInput, input$depClimChangeInput), {
# 
#    # if(!is.null(input$districtMapFuture_click)) {
# #
# #                click <- input$districtMapFuture_click %>%
# #                     data.frame() %>%
# #                     dplyr::select(lat,lng)
# #
# #                     print(click)
# #
# #                 pt <- sf::st_as_sf(
# #                     click,
# #                     coords = c("lng", "lat"),
# #                     crs = 4326
# #                     )
# #
# #
# #                 district_data <- model_data %>%
# #                            filter(district == future_district())
# #                             # filter(district == 6)
# #
# #                 # natural log transform data
# #                 trans_log <- district_data %>%
# #                       mutate(
# #                         short               = log(short),
# #                         short_dir           = log(short_dir),
# #                         short_pct_dem       = log(short_pct_dem),
# #                         short_dir_pct_dem   = log(short_dir_pct_dem),
# #                         aug_supply          = log(aug_supply),
# #                         aug_supply_pct_dem  = log(aug_supply_pct_dem),
# #                         supply              = log(supply),
# #                         supply_dir          = log(supply_dir),
# #                         demand              = log(demand)
# #                         ) %>%
# #                   ungroup() %>%
# #                   group_by(district)
# #
# #                   # ---- replace Infinite w/ 0 ----
# #                   is.na(trans_log) <- sapply(trans_log, is.infinite)
# #                   trans_log[is.na(trans_log)] <- 0
# #
# #                   trans_log <- trans_log %>%
# #                       # dplyr::select(district, short_dir_pct_dem, prcp)
# #                       dplyr::select(district, futureDepVar(), futureClimVar())
# #
# #
# #                   lm_run <- trans_log %>%
# #                         group_by(district) %>%
# #                         nest(-district) %>%
# #                         mutate(
# #                           fit       = map(data,
# #                                            # ~lm(short_dir_pct_dem~prcp, data = .)),
# #                                            ~lm(as.formula(
# #                                              paste0(futureDepVar()," ~ ", futureClimVar())
# #                                            ),
# #                                            data = .)),
# #                           results   = map(fit, augment),
# #                           tidied    = map(fit, tidy),
# #                           metrics   = map(fit, glance)
# #                         ) %>%
# #                         unnest(c(4))
# #
# #                   lm_fit <- lm_run$fit[[1]]
# #
# #                   lm_run2 <- lm_run %>%
# #                     # dplyr::select(district, short_dir_pct_dem, prcp, Fitted = .fitted) %>%
# #                     dplyr::select(district, futureDepVar(), futureClimVar(), Fitted = .fitted) %>%
# #                     setNames(c("district", "dependent_historic", "independent_historic", "fit_historic"))
# #
# #
# #                    future_data <- climate_models %>%
# #                      filter(district == future_district()) %>%
# #                      dplyr::select(district, year, futureClimVar())
# #                      # filter(district == 6) %>%
# #                      # dplyr::select(district, year, prcp)
# #                      # filter(district == future_district(), year > 1950)
# #
# #
# #
# #                    pred_future <- predict(
# #                      lm_fit,
# #                      dplyr::select(future_data, prcp)
# #                      )
# #
# #                    # pred_future <- predict(lm_fit, dplyr::select(future_data,  futureClimVar()))
# #                    pred_df     <- data.frame(
# #                      year    = 1969:2099,
# #                      fitted  =  predict(
# #                                      lm_fit,
# #                                      dplyr::select(future_data,  futureClimVar())
# #                                      )
# #                      # fitted   =  predict(
# #                      #                 lm_fit,
# #                      #                 dplyr::select(future_data, prcp)
# #                      #                 )
# #                      # fitted = pred_future
# #                      ) %>%
# #                      left_join(
# #                        dplyr::select(future_data, -district),
# #                        by = "year"
# #                        ) %>%
# #                      ungroup() %>%
# #                       mutate(
# #                         prediction          = exp(fitted)
# #                       ) %>%
# #                       setNames(c("year", "fitted", "independent_future", "prediction")) %>%
# #                       mutate(across(where(is.numeric), round, 3))
#           # predictor_ts <- future_climate_ts %>%
#                 #   # filter(district == future_district())
#                 #   filter(district == 6)
#                 #
#                 # impact_ts <- mlr_future_fit %>%
#                 #   # filter(district == future_district(), var == futureDepVar())
#                 #   filter(district == 6, var == "short_dir_pct_dem")
#                 #
#                 # district_future_predictors <- mlr_future_predictors %>%
#                 #   filter(district == future_district(), dep_var == futureDepVar()) %>%
#                 #   # filter(district == 6, dep_var == "short_dir_pct_dem") %>%
#                 #   arrange(vif) %>%
#                 #   slice(n = 1:2) %>%
#                 #   dplyr::select(variable)
#                 #
#                 #     future_sample <- samples_future %>%
#                 #       # filter(district == future_district()) %>%
#                 #       # dplyr::select(district, id, contains(paste0(futureClimVar())))
#                 #       filter(district == 6) %>%
#                 #         dplyr::select(district, contains("prcp"))
#                 #       # dplyr::select(district, id, contains("prcp"))
#                 #
#                 #     historic_sample <- samples_historic %>%
#                 #       # filter(district == future_district()) %>%
#                 #       # dplyr::select(district, id, contains(paste0(futureClimVar())))
#                 #       filter(district == 6) %>%
#                 #         dplyr::select(district, contains("prcp"))
#                 #       # dplyr::select(district, id, contains("prcp"))
#                 #
#                 #   # Future density plot
#                 #   density_future <- density(future_sample[[2]])
#                 #   future_yaxis   <- density_future$y
#                 #
#                 #   # Historic density plot
#                 #   density_hist   <- density(historic_sample[[2]])
#                 #   hist_yaxis     <- density_hist$y
#                 #
#                 #   indicator_label <- names(
#                 #     clim_model_indicator_lst[grep(pattern = paste0("^", futureClimVar(), "$"), clim_model_indicator_lst)]
#                 #     # clim_model_indicator_lst[grep(pattern = paste0("prcp"), clim_model_indicator_lst)]
#                 #     )
#                 #
#                 #
#                 #   impact_label    <- names(
#                 #     impacts_lst[grep(pattern = paste0("^", futureDepVar(), "$"), impacts_lst)]
#                 #     # impacts_lst[grep(pattern = paste0("short_dir_pct_dem"), impacts_lst)]
#                 #     )
# 
#                   # plot historic/future sampled data sets
#                  # climate_forecast_plot <-  plot_climate_forecast(
#                  #                  prediction_data = pred_df,
#                  #                  historic_data   = historic_sample,
#                  #                  future_data     = future_sample,
#                  #                  dep_label       = impact_label,
#                  #                  ind_label       = indicator_label
#                  #                  )
#                  #
#                  # climate_forecast_plot
# 
#                    # fitted linear regression predictions data
#                    predictions_df <- lm_future_fit %>%
#                      filter(district == future_district(), dep_var == futureDepVar(), ind_var == futureClimVar()) %>%
#                      # filter(district == "43", dep_var == "short_dir_pct_dem", ind_var == "prcp") %>%
#                      dplyr::select(-district, -dep_var, -ind_var)
# 
#                    # clean predictor label
#                    indicator_label <- clean_names %>%
#                      filter(var == futureClimVar())
#                      # filter(var == "prcp")
#                    indicator_label <- indicator_label$clean_name
# 
#                    # clean dependent variable label
#                    impact_label = clean_names %>%
#                      filter(var == futureDepVar())
#                      # filter(var == "short_dir_pct_dem")
#                    impact_label <- impact_label$clean_name
# 
#                    # climate variable name to filter density columns
#                    sample_var <- paste0(futureClimVar(), "_")
#                    # sample_var <- paste0("prcp", "_")
# 
# 
#                    # future climate density values
#                    future_sample <- samples_future %>%
#                      filter(district == future_district()) %>%
#                      # filter(district == 43) %>%
#                      dplyr::select(district, contains(sample_var)) %>%
#                      setNames(c("district", "x", "y"))
# 
#                    # historical climate density values
#                    historic_sample <- samples_historic %>%
#                      filter(district == future_district()) %>%
#                      # filter(district == 43) %>%
#                      dplyr::select(district, contains(sample_var)) %>%
#                      setNames(c("district", "x", "y"))
# 
#                    # plot historic/future sampled data sets
#                    climate_forecast_plot <-  plot_climate_forecast(
#                                   prediction_data = predictions_df,
#                                   historic_data   = historic_sample,
#                                   future_data     = future_sample,
#                                   dep_label       = impact_label,
#                                   ind_label       = indicator_label
#                                   )
# 
#                    climate_forecast_plot
# 
# })
#
# output$predictionPlot <- renderHighchart({
#   predictImpactsData()
# })

# observeEvent(input$districtMapFuture_click, {
observeEvent(triple_event(), {
  if(is.null(futureClimVar()) | is.null(futureDepVar()) | is.null(future_district())) {
  # if(is.null(input$climChangeVarInput) | is.null(input$depClimChangeInput) | is.null(input$districtMapFuture_shape_click$id)) {
  # if(is.null(triple_event())) {
    return(NULL)
    
    } else {
      
                   # fitted linear regression predictions data
                   predictions_df <- lm_future_fit %>%
                     filter(district == future_district(), dep_var == futureDepVar(), ind_var == futureClimVar()) %>%
                     # filter(district == "43", dep_var == "short_dir_pct_dem", ind_var == "prcp") %>%
                     dplyr::select(-district, -dep_var, -ind_var)

                   # clean predictor label
                   indicator_label <- clean_names %>%
                     filter(var == futureClimVar())
                     # filter(var == "prcp")
                   indicator_label <- indicator_label$clean_name

                   # clean dependent variable label
                   impact_label = clean_names %>%
                     filter(var == futureDepVar())
                     # filter(var == "short_dir_pct_dem")
                   impact_label <- impact_label$clean_name

                   # climate variable name to filter density columns
                   sample_var <- paste0(futureClimVar(), "_")
                   # sample_var <- paste0("prcp", "_")


                   # future climate density values
                   future_sample <- samples_future %>%
                     filter(district == future_district()) %>%
                     # filter(district == 43) %>%
                     dplyr::select(district, contains(sample_var)) %>%
                     setNames(c("district", "x", "y"))

                   # historical climate density values
                   historic_sample <- samples_historic %>%
                     filter(district == future_district()) %>%
                     # filter(district == 43) %>%
                     dplyr::select(district, contains(sample_var)) %>%
                     setNames(c("district", "x", "y"))

                   # plot historic/future sampled data sets
                   climate_forecast_plot <-  plot_climate_forecast(
                                  prediction_data = predictions_df,
                                  historic_data   = historic_sample,
                                  future_data     = future_sample,
                                  dep_label       = impact_label,
                                  ind_label       = indicator_label
                                  )

                   climate_forecast_plot
                   
                   output$predictionPlot <- renderHighchart({
                     climate_forecast_plot
                     })
    }

})
```

Column {data-width=550}
-------------------------------------
###
```{r}
highcharter::highchartOutput("MLRpredictionPlot")
```

```{r context = "server"}
# MLRpredictionData <- eventReactive(input$submitButton2, {
   # if(!is.null(input$districtMapFuture_click)) {
              #  click <- input$districtMapFuture_click %>%
              #       data.frame() %>%
              #       dplyr::select(lat,lng)
              #
              #       print(click)
              #
              #   pt <- sf::st_as_sf(
              #       click,
              #       coords = c("lng", "lat"),
              #       crs = 4326
              #       )
              #
              #
              #   district_data <- model_data %>%
              #              filter(district == future_district(),  year <= 2012)
              #               # filter(district == 64,  year <= 2012)
              #              # filter(district == district_id$district)
              #
              # #      # # ---- log transform data ----
              #   mod_df <- district_data %>%
              #         mutate(
              #           short               = log(short),
              #           short_dir           = log(short_dir),
              #           short_pct_dem       = log(short_pct_dem),
              #           short_dir_pct_dem   = log(short_dir_pct_dem),
              #           aug_supply          = log(aug_supply),
              #           aug_supply_pct_dem  = log(aug_supply_pct_dem),
              #           supply              = log(supply),
              #           supply_dir          = log(supply_dir),
              #           demand              = log(demand)
              #         ) %>%
              #       dplyr::select(futureDepVar(), prcp, tavg, tmax, tmin, pdsi, pet, spi1, spi3, spi6, spi9, spi12)
              #       # dplyr::select(short_dir_pct_dem,  prcp, tavg, tmax, tmin, pdsi, pet, spi1, spi3, spi6, spi9, spi12)
              #
              #
              #     # ---- Prep data for model ----
              #     # replace Infinite w/ 0
              #     is.na(mod_df) <- sapply(mod_df, is.infinite)
              #     mod_df[is.na(mod_df)] <- 0
              #
              #
              #
              #     # multivariate stepwise regression
              #     lm_run <- lm(
              #       # short_dir_pct_dem~., data = mod_df) %>%
              #                   as.formula(
              #                     paste0(futureDepVar()," ~ .")),
              #                   data = mod_df) %>%
              #               # rm_collinearity(vif_thresh = 3.5) %>%
              #                ols_step_both_p()
              #                # ols_step_forward_p()
#
#                   if(length(lm_run$predictors) > 1) {
#
#                       vf_df <- data.frame(vif = car::vif(lm_run$model)) %>%
#                         rownames_to_column() %>%
#                         arrange(vif) %>%
#                         slice(n = 1:3)
#
#                       # step wise regression
#                       lm_step <- lm(
#                         as.formula(futureDepVar(), paste(vf_df$rowname, collapse=" + "), sep=" ~ "),
#                         # as.formula(paste("short_dir_pct_dem", paste(vf_df$rowname, collapse=" + "), sep=" ~ ")),
#                         data = mod_df
#                         )
#
#                       # ---- Select predictors from data ----
#
#                   # Future MACA data for individual district
#                   climate_proj <- climate_models %>%
#                       filter(district == future_district(), year >=  2020) %>%
#                       # filter(district == 64, year >= 2020) %>%
#                       mutate(across(where(is.numeric), round, 3))
#                       # setNames(c("year", "climate_var"))
#
#                   # predict future shorts past 2021
#                   pred_df <- data.frame(
#                       year   = 2020:2099,
#                       fitted = predict(lm_step, climate_proj)
#                       ) %>%
#                     mutate(
#                       prediction          = exp(fitted)
#                     ) %>%
#                     mutate(across(where(is.numeric), round, 2))
#
#                  #         # 2013-2020 Observed data for individual district
#                  current_data <- present_climate %>%
#                       filter(district == future_district(), year >=  2013, year <=  2019) %>%
#                       # filter(district == 64,  year >=  2013, year <=  2019) %>%
#                       dplyr::select(-year, -district) %>%
#                       mutate(across(where(is.numeric), round, 3))
#
#                   # predict current shorts 2013-2020, apply model to observed data from 2013 - 2020
#                   pred_current_df <- data.frame(
#                               year   = 2013:2019,
#                               fitted = predict(lm_step, current_data)
#                               ) %>%
#                     mutate(
#                       prediction          = exp(fitted)
#                         ) %>%
#                     mutate(across(where(is.numeric), round, 2))
#
#
#                   # clean impacts label
#                   impact_label <- names(
#                        impacts_lst[grep(pattern = paste0("^", futureDepVar(), "$"), impacts_lst)]
#                        # impacts_lst[grep(pattern = paste0("short_dir_pct_dem"), impacts_lst)]
#                       )
#
#                   # clean indicators label
#                   indicator_label <- names(
#                        clim_model_indicator_lst[grep(pattern = paste0("^", futureClimVar(), "$"), clim_model_indicator_lst)]
#                        # clim_model_indicator_lst[grep(pattern = paste0("prcp"), clim_model_indicator_lst)]
#                       )
#
#                   # historic impacts
#                   impact_historic <- district_data %>%
#                       dplyr::select(year, futureDepVar()) %>%
#                       # dplyr::select(year, short_dir_pct_dem) %>%
#                       mutate(
#                          year    = as.numeric(as.character(year)),
#                          source  = "historic"
#                       ) %>%
#                       setNames(c("year", "impact", "source"))
#
#                   # predicted current impacts
#                   impact_current <- pred_current_df %>%
#                       # filter(year > 2020) %>%
#                       dplyr::select(year, prediction) %>%
#                       mutate(source = "current") %>%
#                       setNames(c("year", "impact", "source"))
#
#                   # predicted future impacts
#                   impact_projected <- pred_df %>%
#                       filter(year >= 2020) %>%
#                       dplyr::select(year, prediction) %>%
#                       mutate(source = "projected") %>%
#                       setNames(c("year", "impact", "source"))
#
#                   # join historic impacts data w/ predicted impacts
#                   impact_ts <- bind_rows(impact_historic, impact_current, impact_projected)
#
#
#
#                 # ---- Select predictors from data ----
#                 hist_predictors <- district_data %>%
#                     dplyr::select(year, vf_df$rowname) %>%
#                     # dplyr::select(year, lm_run$predictors[1:2]) %>%
#                     mutate(across(where(is.numeric), round, 2)) %>%
#                     mutate(year = as.numeric(as.character(year)))
#
#                 current_predictors <- present_climate  %>%
#                   filter(district == future_district(), year >= 2013,  year <=  2019) %>%
#                    # filter(district == 64, year >= 2013,  year <=  2019) %>%
#                    dplyr::select(year, vf_df$rowname) %>%
#                    mutate(across(where(is.numeric), round, 2)) %>%
#                    mutate(year = as.numeric(as.character(year)))
#
#                 future_predictors <- climate_models %>%
#                     filter(district == future_district(), year >= 2020) %>%
#                    # filter(district == 64, year >= 2020) %>%
#                     dplyr::select(year, vf_df$rowname) %>%
#                     mutate(across(where(is.numeric), round, 2))
#
#                 predictor_ts <- bind_rows(hist_predictors, current_predictors, future_predictors)
#
#                 name_df <- data.frame(
#                             swe_max           = "SWE maximum (in)",
#                             prcp              = "Precipitation (mm)",
#                             pdsi              = "PDSI",
#                             eddi1             = "EDDI 1 month",
#                             eddi3             = "EDDI 3 month",
#                             eddi6             = "EDDI 6 month",
#                             eddi12            = "EDDI 12 month",
#                             spi1              = "SPI 1 month",
#                             spi3              = "SPI 3 month",
#                             spi6              = "SPI 6 month",
#                             spi9              = "SPI 9 month",
#                             spi12             = "SPI 12 month",
#                             tavg              = "Average temperature (C)",
#                             tmax              = "Maximum temperature (C)",
#                             tmin              = "Minimum temperature (C)",
#                             pet               = "Potential Evapotranspiration (mm)",
#                             soilm             = "Soil moisture (mm)") %>%
#                   pivot_longer(
#                     cols      = everything(),
#                     names_to  = "var",
#                     values_to = "clean_name"
#                     ) %>%
#                      filter(var %in% vf_df$rowname)
#
#                 future_prediction_plot <- plot_future_prediction(
#                                                             predictors  = predictor_ts,
#                                                             impacts     = impact_ts,
#                                                             clean_text  = name_df,
#                                                             dep_label   = impact_label,
#                                                             ind_label   = indicator_label
#                                                           )
#                 future_prediction_plot
#
#                 } else {
#
#                     # step wise regression
#                     lm_step <- lm(
#                         as.formula(futureDepVar(), paste(lm_run$predictors, collapse=" + "), sep=" ~ "),
#                         # as.formula(paste("short_dir_pct_dem", paste(lm_run$predictors, collapse=" + "), sep=" ~ ")),
#                         data = mod_df
#                         )
#
#                       # ---- Select predictors from data ----
#
#                   # Future MACA data for individual district
#                   climate_proj <- climate_models %>%
#                       filter(district == future_district(), year >=  2020) %>%
#                       # filter(district == 5, year >= 2020) %>%
#                       mutate(across(where(is.numeric), round, 3))
#                       # setNames(c("year", "climate_var"))
#
#                   # predict future shorts past 2021
#                   pred_df <- data.frame(
#                       year   = 2020:2099,
#                       fitted = predict(lm_step, climate_proj)
#                       ) %>%
#                     mutate(
#                       prediction          = exp(fitted)
#                     ) %>%
#                     mutate(across(where(is.numeric), round, 2))
#
#                  #         # 2013-2020 Observed data for individual district
#                  current_data <- present_climate %>%
#                       filter(district == future_district(), year >=  2013, year <=  2019) %>%
#                       # filter(district == 5,  year >=  2013, year <=  2019) %>%
#                       dplyr::select(-year, -district) %>%
#                       mutate(across(where(is.numeric), round, 3))
#
#                   # predict current shorts 2013-2020, apply model to observed data from 2013 - 2020
#                   pred_current_df <- data.frame(
#                               year   = 2013:2019,
#                               fitted = predict(lm_step, current_data)
#                               ) %>%
#                     mutate(
#                       prediction          = exp(fitted)
#                         ) %>%
#                     mutate(across(where(is.numeric), round, 2))
#
#
#                   # clean impacts label
#                   impact_label <- names(
#                        impacts_lst[grep(pattern = paste0("^", futureDepVar(), "$"), impacts_lst)]
#                        # impacts_lst[grep(pattern = paste0("short_dir_pct_dem"), impacts_lst)]
#                       )
#
#                   # clean indicators label
#                   indicator_label <- names(
#                        clim_model_indicator_lst[grep(pattern = paste0("^", futureClimVar(), "$"), clim_model_indicator_lst)]
#                        # clim_model_indicator_lst[grep(pattern = paste0("prcp"), clim_model_indicator_lst)]
#                       )
#
#                   # historic impacts
#                   impact_historic <- district_data %>%
#                       dplyr::select(year, futureDepVar()) %>%
#                       # dplyr::select(year, short_dir_pct_dem) %>%
#                       mutate(
#                          year    = as.numeric(as.character(year)),
#                          source  = "historic"
#                       ) %>%
#                       setNames(c("year", "impact", "source"))
#
#                   # predicted current impacts
#                   impact_current <- pred_current_df %>%
#                       # filter(year > 2020) %>%
#                       dplyr::select(year, prediction) %>%
#                       mutate(source = "current") %>%
#                       setNames(c("year", "impact", "source"))
#
#                   # predicted future impacts
#                   impact_projected <- pred_df %>%
#                       filter(year >= 2020) %>%
#                       dplyr::select(year, prediction) %>%
#                       mutate(source = "projected") %>%
#                       setNames(c("year", "impact", "source"))
#
#                   # join historic impacts data w/ predicted impacts
#                   impact_ts <- bind_rows(impact_historic, impact_current, impact_projected)
#
#
#
#                 # ---- Select predictors from data ----
#                 hist_predictors <- district_data %>%
#                     dplyr::select(year, lm_run$predictors) %>%
#                     # dplyr::select(year, lm_run$predictors[1:2]) %>%
#                     mutate(across(where(is.numeric), round, 2)) %>%
#                     mutate(year = as.numeric(as.character(year)))
#
#                 current_predictors <- present_climate  %>%
#                   filter(district == future_district(), year >= 2013,  year <=  2019) %>%
#                    # filter(district == 5, year >= 2013,  year <=  2019) %>%
#                    dplyr::select(year, lm_run$predictors) %>%
#                    mutate(across(where(is.numeric), round, 2)) %>%
#                    mutate(year = as.numeric(as.character(year)))
#
#                 future_predictors <- climate_models %>%
#                     filter(district == future_district(), year >= 2020) %>%
#                    # filter(district == 5, year >= 2020) %>%
#                     dplyr::select(year, lm_run$predictors) %>%
#                     mutate(across(where(is.numeric), round, 2))
#
#                 predictor_ts <- bind_rows(hist_predictors, current_predictors, future_predictors)
#
#                 name_df <- data.frame(
#                             swe_max           = "SWE maximum (in)",
#                             prcp              = "Precipitation (mm)",
#                             pdsi              = "PDSI",
#                             eddi1             = "EDDI 1 month",
#                             eddi3             = "EDDI 3 month",
#                             eddi6             = "EDDI 6 month",
#                             eddi12            = "EDDI 12 month",
#                             spi1              = "SPI 1 month",
#                             spi3              = "SPI 3 month",
#                             spi6              = "SPI 6 month",
#                             spi9              = "SPI 9 month",
#                             spi12             = "SPI 12 month",
#                             tavg              = "Average temperature (C)",
#                             tmax              = "Maximum temperature (C)",
#                             tmin              = "Minimum temperature (C)",
#                             # aet               = "Actual evapotranspiration (mm)",
#                             pet               = "Potential Evapotranspiration (mm)",
#                             soilm             = "Soil moisture (mm)") %>%
#                   pivot_longer(
#                     cols      = everything(),
#                     names_to  = "var",
#                     values_to = "clean_name"
#                     ) %>%
#                      filter(var %in% district_future_predictors$variable)

#                 predictor_ts <- future_climate_ts %>%
#                   filter(district == future_district())
#                   # filter(district == 8)
# 
#                 impact_ts <- mlr_future_fit %>%
#                   filter(district == future_district(), var == futureDepVar())
#                   # filter(district == 8, var == "short_dir_pct_dem")
# 
#                 district_future_predictors <- mlr_future_predictors %>%
#                   filter(district == future_district(), dep_var == futureDepVar()) %>%
#                   # filter(district == 8, dep_var == "short_dir_pct_dem") %>%
#                   arrange(vif) %>%
#                   slice(n = 1:2) %>%
#                   dplyr::select(variable)
# 
#                if(length(district_future_predictors$variable) > 1) {
#                 # log message
#                 logger::log_info("Multiple predictors")
# 
#                 # name dataframe
#                 name_data <- clean_names %>%
#                   filter(var %in% district_future_predictors$variable)
# 
#                 # clean predictor label
#                 indicator_label <-  name_data$clean_name
# 
#                 # clean dependent variable label
#                 impact_label = clean_names %>%
#                   filter(var == futureDepVar())
#                   # filter(var == "short_dir_pct_dem")
#                 impact_label <- impact_label$clean_name
# 
#                 future_prediction_plot <- plot_future_prediction(
#                                                                 predictors  = predictor_ts,
#                                                                 impacts     = impact_ts,
#                                                                 clean_text  = name_data,
#                                                                 dep_label   = impact_label,
#                                                                 ind_label   = indicator_label,
#                                                                 number_vars = 2
#                                                               )
#                 future_prediction_plot
#                } else {
#                 # log message
#                 logger::log_info("Single predictors")
# 
#                 # name dataframe
#                 name_data <- clean_names %>%
#                   filter(var %in% district_future_predictors$variable)
# 
#                 # clean predictor label
#                 indicator_label <-  name_data$clean_name
# 
#                 # clean dependent variable label
#                 impact_label = clean_names %>%
#                   filter(var == futureDepVar())
#                    # filter(var == "short_dir_pct_dem")
#                 impact_label <- impact_label$clean_name
# 
#                 future_prediction_plot <- plot_future_prediction(
#                                                                 predictors  = predictor_ts,
#                                                                 impacts     = impact_ts,
#                                                                 clean_text  = name_data,
#                                                                 dep_label   = impact_label,
#                                                                 ind_label   = indicator_label,
#                                                                 number_vars = 1
#                                                               )
#                 future_prediction_plot
#                 }
# })
# #
# # render predictions and indepedent variables plots
# output$MLRpredictionPlot <- highcharter::renderHighchart({
#   MLRpredictionData()
# })
observeEvent(input$submitButton2, {
  if(is.null(futureClimVar()) | is.null(futureDepVar()) | is.null(future_district())) {
  # if(is.null(input$climChangeVarInput) | is.null(input$depClimChangeInput) | is.null(input$districtMapFuture_shape_click$id)) {
  # if(is.null(triple_event())) {
    return(NULL)
    
    } else {
      
                predictor_ts <- future_climate_ts %>%
                  filter(district == future_district())
                  # filter(district == 8)

                impact_ts <- mlr_future_fit %>%
                  filter(district == future_district(), var == futureDepVar())
                  # filter(district == 8, var == "short_dir_pct_dem")

                district_future_predictors <- mlr_future_predictors %>%
                  filter(district == future_district(), dep_var == futureDepVar()) %>%
                  # filter(district == 8, dep_var == "short_dir_pct_dem") %>%
                  arrange(vif) %>%
                  slice(n = 1:2) %>%
                  dplyr::select(variable)

               if(length(district_future_predictors$variable) > 1) {
                # log message
                logger::log_info("Multiple predictors")

                # name dataframe
                name_data <- clean_names %>%
                  filter(var %in% district_future_predictors$variable)

                # clean predictor label
                indicator_label <-  name_data$clean_name

                # clean dependent variable label
                impact_label = clean_names %>%
                  filter(var == futureDepVar())
                  # filter(var == "short_dir_pct_dem")
                impact_label <- impact_label$clean_name

                future_prediction_plot <- plot_future_prediction(
                                                                predictors  = predictor_ts,
                                                                impacts     = impact_ts,
                                                                clean_text  = name_data,
                                                                dep_label   = impact_label,
                                                                ind_label   = indicator_label,
                                                                number_vars = 2
                                                              )
                
                # render predictions and indepedent variables plots
                output$MLRpredictionPlot <- highcharter::renderHighchart({
                  future_prediction_plot
                  })
                
               } else {
                # log message
                logger::log_info("Single predictors")

                # name dataframe
                name_data <- clean_names %>%
                  filter(var %in% district_future_predictors$variable)

                # clean predictor label
                indicator_label <-  name_data$clean_name

                # clean dependent variable label
                impact_label = clean_names %>%
                  filter(var == futureDepVar())
                   # filter(var == "short_dir_pct_dem")
                impact_label <- impact_label$clean_name

                future_prediction_plot <- plot_future_prediction(
                                                                predictors  = predictor_ts,
                                                                impacts     = impact_ts,
                                                                clean_text  = name_data,
                                                                dep_label   = impact_label,
                                                                ind_label   = indicator_label,
                                                                number_vars = 1
                                                              )
                
                # render predictions and indepedent variables plots
                output$MLRpredictionPlot <- highcharter::renderHighchart({
                  future_prediction_plot
                  })
               }
    }
})
#
# # render predictions and indepedent variables plots
# output$MLRpredictionPlot <- highcharter::renderHighchart({
#   MLRpredictionData()
# })
```


### Model summary {data-height=50}
```{r}
# formattable::formattableOutput("futureModelSummary")
reactable::reactableOutput("futureModelSummary")
bsPopover("futureModelSummary", title = "Model Summary", content = "This is a summary table containing the coefficients and R Squared for the linear model. The regression coefficient values (values in red) signifies the strength of the relationship and is the m in the regression equation “y = mx +b”. The sign of this value tells us whether there is a positive or negative correlation between the climate predictor and the response variable. A positive coefficient indicates that as the value of climate variable increases, the mean of the response variable also tends to increase. A negative coefficient suggests that as the climate variable increases, the dependent variable tends to decrease. ", placement = "left", options = list(container = "body"))
# bsTooltip("futureModelSummary", "INSERT TEXT HERE",
#                     "top", options = list(container = "body"))
tags$style(HTML("
                .tooltip > .tooltip-inner {
                width: 400px;
                color: black;
                background-color: white;
                }
                "))

```

```{r context = "server"}
observeEvent(input$submitButton2, {
  if(is.null(futureClimVar()) | is.null(futureDepVar()) | is.null(future_district())) {
  # if(is.null(input$climChangeVarInput) | is.null(input$depClimChangeInput) | is.null(input$districtMapFuture_shape_click$id)) {
  # if(is.null(triple_event())) {
    return(NULL)
    
    } else {
      mlr_table_summary <- mlr_future_metrics %>%
        filter(district == future_district(), dep_var == futureDepVar()) %>%
        # filter(district == 6, dep_var == "short_dir_pct_dem") %>%
        dplyr::select(-district, -dep_var, -term) %>%
        pivot_wider(
          names_from  = "clean_name",
          values_from = "estimate"
                  )
      # logger::log_info("{futureDepVar()}")
      # logger::log_info("{future_district()}")
      # rsq_colors <- data.frame("R squared" = c(0, 1))
      # Clean MLR summary table
      mlr_table <- make_mlr_table(
        table_data = mlr_table_summary
        )
      
      output$futureModelSummary <- reactable::renderReactable({
        mlr_table
      })
      }
  })
# futureModelSummaryData <- eventReactive(input$submitButton2, {
   # if(!is.null(input$districtMapFuture_click)) {
    # click <- input$districtMapFuture_click %>%
    #         data.frame() %>%
    #         dplyr::select(lat,lng)
    #
    #       pt <- sf::st_as_sf(
    #         click,
    #         coords = c("lng", "lat"),
    #         crs = 4326
    #         )
    #       # point intersection w/ polygons
    #       pt_intersect <-  st_filter(shp, pt)
    #
    #       # ensure  app will not crash if a somewhere other than a shape is clicked and returns no results from point-shape intersection
    #       if(nrow(pt_intersect) == 0) {
    #           NULL
    #          } else {
    #             district_id <- pt_intersect %>%
    #                 rename(district = DISTRICT) %>%
    #                 mutate(district = as.numeric(district))
    #              # ---- Water supply data summarized to the year ----
    #             ws_data <- by_admin %>%
    #               group_by(year, district) %>%
    #               mutate(
    #                   year          = as.factor(year),
    #                   admin_number  = as.integer(round(admin, 0))
    #               ) %>%
    #               dplyr::filter(!year %in% c(1980, 2013)) %>%
    #               group_by(basin, district, year) %>%
    #               summarise(
    #                   short               = sum(short, na.rm = T),
    #                   short_dir           = sum(short_dir, na.rm = T),
    #                   demand              = sum(demand, na.rm = T),
    #                   supply              = sum(supply, na.rm = T),
    #                   supply_dir          = sum(supply_dir, na.rm = T)
    #               ) %>%
    #               mutate(
    #                   short_pct_dem          = 100*(round(short/demand, 3)),
    #                   short_dir_pct_dem      = 100*(round(short_dir/demand, 3)),
    #                   aug_supply          = round((supply - supply_dir), 3),
    #                   aug_supply_pct_dem     = round(100*(aug_supply/supply), 3),
    #                   year                = as.factor(year)
    #               )
    #
    #             # ---- Join indicators & impacts data, summarize to district level ----
    #             by_district <- left_join(
    #                   ws_data,
    #                   dplyr::select(short_year, year = wyear, district, 20:41),
    #                   by = c("district", "year")
    #             ) %>%
    #               # filter(district == 9) %>%
    #               filter(district == future_district()) %>%
    #               dplyr::filter(!year %in% c(1980, 2013)) %>%
    #               group_by(basin, district, year) %>%
    #               summarise(
    #                     short               = sum(short, na.rm = T),
    #                     short_dir           = sum(short_dir, na.rm = T),
    #                     demand              = sum(demand, na.rm = T),
    #                     supply              = sum(supply, na.rm = T),
    #                     supply_dir          = sum(supply_dir, na.rm = T),
    #                     swe_max             = mean(swe_max, na.rm = T),
    #                     prcp                = mean(prcp, na.rm = T),
    #                     prcp_norm           = mean(prcp_norm, na.rm = T),
    #                     # pdsi                = mean(pdsi, na.rm = T),
    #                     pdsi                = mean(pdsi_gridmet, na.rm = T),
    #                     eddi1               = mean(eddi1, na.rm = T),
    #                     eddi3               = mean(eddi3, na.rm = T),
    #                     eddi6               = mean(eddi6, na.rm = T),
    #                     eddi12              = mean(eddi12, na.rm = T),
    #                     spi1                = mean(spi1, na.rm = T),
    #                     spi3                = mean(spi3, na.rm = T),
    #                     spi6                = mean(spi6, na.rm = T),
    #                     spi9                = mean(spi9, na.rm = T),
    #                     spi12               = mean(spi12, na.rm = T),
    #                     tavg                = mean(tavg, na.rm = T),
    #                     aet                 = mean(aet, na.rm = T),
    #                     pet                 = mean(pet, na.rm = T),
    #                     soilm               = mean(soilm, na.rm = T)
    #               ) %>%
    #               mutate(
    #                     short_pct_dem          = 100*(round(short/demand, 3)),
    #                     short_dir_pct_dem      = 100*(round(short_dir/demand, 3)),
    #                     aug_supply          = round((supply - supply_dir), 3),
    #                     aug_supply_pct_dem     = round(100*(aug_supply/supply), 3),
    #                     year                = as.factor(year)
    #               )
    #             # ---- log transform data ----
    #             mod_df <- by_district %>%
    #                   mutate(
    #                     short               = log(short),
    #                     short_dir           = log(short_dir),
    #                     short_pct_dem          = log(short_pct_dem),
    #                     short_dir_pct_dem      = log(short_dir_pct_dem),
    #                     aug_supply          = log(aug_supply),
    #                     aug_supply_pct_dem     = log(aug_supply_pct_dem),
    #                     supply              = log(supply),
    #                     supply_dir          = log(supply_dir),
    #                     demand              = log(demand)
    #                   ) %>% ungroup()
    #
    #             # ---- Prep data for model ----
    #             mod_df <- mod_df %>%
    #                     # dplyr::select(short_dir_pct_dem, prcp, tavg, pdsi, spi1,spi3, spi6, spi9, spi12)
    #                   dplyr::select(futureDepVar(), prcp, tavg, pdsi, spi1,spi3, spi6, spi9, spi12)
    #
    #
    #                 mlr_df2 <- model_data %>%
    #                   filter(district == 1) %>%
    #                   dplyr::select(dependent_vars[1], prcp:spi12)
    #
    #                 # lm_data[,1] <-  lm_data[,1]
    #                 mlr_df2[,1] <- log(mlr_df2[,1])
    #
    #                 # replace Infinite w/ 0
    #                 is.na(mlr_df2) <- sapply(mlr_df2, is.infinite)
    #                 mlr_df2[is.na(mlr_df2)] <- 0
    #
    #                 mlr_model2 <- lm(
    #                   paste0(dependent_vars[1], "~."),
    #                   data = mlr_df2
    #                 ) %>%
    #                   olsrr::ols_step_forward_p()
    #
    #                 # Calculate VIF
    #                 vf <- car::vif(mlr_model2$model)
    #
    #                 # VIF - remove variables w/ VIF > 5
    #                 vf_df <- data.frame(vif = vf) %>%
    #                   rownames_to_column() %>%
    #                   arrange(vif) %>%
    #                   slice(n = 1:3)
    #                 # filter(vif <= 5)
    #
    #                 # log_info("selecting {vf_df$rowname}")
    #
    #                 # step wise regression
    #                 mlr_step2 <- lm(
    #                   as.formula(paste(dependent_vars[1], paste(vf_df$rowname, collapse=" + "), sep=" ~ ")),
    #                   data = mlr_df2
    #                   )
    #
    #                 results   <-  augment(mlr_step2)
    #                 tidied    <-  tidy(mlr_step2)
    #                 metrics   <-  glance(mlr_step2)
    #
    #             rsq_pval    <-  metrics %>%
    #               dplyr::select(r_squared = r.squared, p_value = p.value) %>%
    #               mutate(across(where(is.numeric), round, 3))
    #               # pivot_longer(cols = c(1:2)) %>%
    #               # setNames(c("term", "estimate"))
    #
    #             coeff  <-  tidied %>%
    #               dplyr::select(term, estimate) %>%
    #               mutate(across(where(is.numeric), round, 3)) %>%
    #               pivot_wider(names_from = "term", values_from = "estimate")
    #
    #
    #             tbl_all <- bind_cols(coeff, rsq_pval)
    #             # replace Infinite w/ 0
    #             is.na(mod_df) <- sapply(mod_df, is.infinite)
    #             mod_df[is.na(mod_df)] <- 0
    #
    #                 # ---- Linear regression run, nested dataframe ----
    #                 # multivariate stepwise regression
    #             lm_run <- lm(
    #                 # short_dir_pct_dem~., data = mod_df) %>%
    #                             as.formula(
    #                               paste0(futureDepVar()," ~ .")),
    #                             data = mod_df) %>%
    #                         # rm_collinearity(vif_thresh = 3.5) %>%
    #                         ols_step_forward_p()
    #
    #             lm_model  <-  lm_run$model
    #
    #             results   <-  augment(lm_model)
    #             tidied    <-  tidy(lm_model)
    #             metrics   <-  glance(lm_model)
    #
    #             rsq_pval    <-  metrics %>%
    #               dplyr::select(r_squared = r.squared, p_value = p.value) %>%
    #               mutate(across(where(is.numeric), round, 3))
    #               # pivot_longer(cols = c(1:2)) %>%
    #               # setNames(c("term", "estimate"))
    #
    #             coeff  <-  tidied %>%
    #               dplyr::select(term, estimate) %>%
    #               mutate(across(where(is.numeric), round, 3)) %>%
    #               pivot_wider(names_from = "term", values_from = "estimate")
    #
    #
    #             tbl_all <- bind_cols(coeff, rsq_pval)
    #
    #             # recode names
    #             clean_names <- names(rename_all(tbl_all, recode,
    #                                            "(Intercept)"     = "Intercept",
    #                                            r_squared         = "R2",
    #                                            p_value           = "p-value",
    #                                            swe_max           = "SWE maximum",
    #                                            prcp              = "Precipitation",
    #                                            pdsi              = "PDSI",
    #                                            eddi1             = "EDDI 1 month",
    #                                            eddi3             = "EDDI 3 month",
    #                                            eddi6             = "EDDI 6 month",
    #                                            eddi12            = "EDDI 12 month",
    #                                            spi1              = "SPI 1 month",
    #                                            spi3              = "SPI 3 month",
    #                                            spi6              = "SPI 6 month",
    #                                            spi9              = "SPI 9 month",
    #                                            spi12             = "SPI 12 month",
    #                                            tavg              = "Average Temperature",
    #                                            tmax              = "Maximum temperature",
    #                                            tmin              = "Minimum temperature",
    #                                            aet               = "Actual evapotranspiration",
    #                                            pet               = "PET",
    #                                            soilm             = "Soil moisture (mm)")
    #
    #
    #             )
    #
    #             tbl_clean <-  tbl_all %>% setNames(clean_names)

              # mlr_table_summary <- mlr_future_metrics %>%
              #   filter(district == future_district(), dep_var == futureDepVar()) %>%
              #   # filter(district == 6, dep_var == "short_dir_pct_dem") %>%
              #   dplyr::select(-district, -dep_var, -term) %>%
              #   pivot_wider(
              #     names_from  = "clean_name",
              #     values_from = "estimate"
              #     )
              # # logger::log_info("{futureDepVar()}")
              # # logger::log_info("{future_district()}")
              # # logger::log_info("{futureClimVar()}")
              # # rsq_colors <- data.frame("R squared" = c(0, 1))
              # 
              # # Clean MLR summary table
              # mlr_table <- make_mlr_table(
              #   table_data = mlr_table_summary
              #   )
              # 
              # mlr_table
              # 
              # })

# output$futureModelSummary <- renderFormattable({
#                   futureModelSummaryData()
#                   })
# output$futureModelSummary <- reactable::renderReactable({
#                   futureModelSummaryData()
#                   })
```
